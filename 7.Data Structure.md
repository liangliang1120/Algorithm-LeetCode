## [第七课：数据结构 Data Structure]()

### [Stack栈 and queue队列]()
队列 queue：
支持操作:O(1) Push / O(1) Pop / O(1) Top  
BFS的主要数据结构 多做做BFS的题就可以了
BFS的主要数据结构是 Queue // DFS 的主要数据结构是 Stack 

栈 stack：
数组//链表 支持操作:O(1) Push / O(1) Pop / O(1) Top 
非递归实现DFS的主要数据结构

#### [Stack - Queue Implement]()
- [0232.Implement Queue using Stacks](Solutions/232.Implement_Queue_using_Stacks)(E)  <br>
- [0225.Implement Stack using Queues](Solutions/0225.Implement_Stack_using_Queues.java) (E) <br>

#### [Stack - Valid]()
- [0946.Validate_Stack_Sequences.py](Solutions/0946.Validate_Stack_Sequences.py)  (!!!M Google)<br>

#### [Stack - Parentheses problems]()
- [0020.Valid_Parentheses.py](Solutions/0020.Valid_Parentheses.py)(!!E) <br>
- [0921.Minimum_Add_to_Make_Parentheses_Valid.py](Solutions/0921.Minimum_Add_to_Make_Parentheses_Valid.py) (!!M) <br>
- [1047.Remove_All_Adjacent_Duplicates_In_String.py](Solutions/1047.Remove_All_Adjacent_Duplicates_In_String.py)(!!E) <br>
  list转成string: "".join(array) <br>
- [1209.Remove_All_Adjacent_Duplicates_in_String_II.py](Solutions/1209.Remove_All_Adjacent_Duplicates_in_String_II.py)(M) <br>
  stack store the dict(value, count)
- [1249.Minimum_Remove_to_Make_Valid_Parentheses.py](Solutions/1249.Minimum_Remove_to_Make_Valid_Parentheses.py)(M) <br>
  Next:Review 
- [0856.Score_of_Parentheses.py](Solutions/0856.Score_of_Parentheses.py)(!!M) <br>
- [0346.Moving_Average_from_Data_Stream.py](Solutions/0346.Moving_Average_from_Data_Stream.py) (!!E Google) <br>
- [0716.Max Stack](Solutions/0716.Max_Stack.py) (E) <br>
- [0155.Min Stack](Solutions/0155.Min_Stack.py) (!!E) <br>

#### [Stack - Decode String]()
- [0394.Decode_String.py](Solutions/0394.Decode_String.py)(!!M Google) <br>
  Next:Review
  TODO: 726（H）

#### [Stack - Calculator]()
TODO:
224
227

#### [Flatten Nested List Iterator]()
Iterator:  主程序在next中实现，hasNext()
- [0341.Flatten_Nested_List_Iterator](Solutions/0341.Flatten_Nested_List_Iterator.py)(!!M) <br>
  Next: Review 写起来不好写
- [0173.Binary_Search_Tree_Iterator](Solutions/0173.Binary_Search_Tree_Iterator.py)(!!M) <br>
  Next: Review 写起来不好写
- [0281.Zigzag_Iterator](Solutions/0281.Zigzag_Iterator.py)(!!M) <br>
  Next: Review 写起来不好写
- [0251.Flatten_2D_Vector.py](Solutions/0251.Flatten_2D_Vector.py)(!!M) <br>

#### [Stack - Mono stack-用于向左/向右寻找第一个比自己大/小的数]()
- [0496.Next_Greater_Element_I.py](Solutions/0496.Next_Greater_Element_I.py)(E) <br>
  单调递减栈，寻找右边第一个比自己大的数.大于栈顶就出栈，小于就入栈. 套用模板即可
- [0503.Next_Greater_Element_II.py](Solutions/0503.Next_Greater_Element_II.py)(M) <br>
  TODO: 556. Next Greater Element III  类似31题(M)
- [0739.Daily_Temperatures.py](Solutions/0739.Daily_Temperatures.py)(M) <br>
  TODO: 316.Remove Duplicate Letters （H）
- [0901.Online_Stock_Span.py](Solutions/0901.Online_Stock_Span.py)(M) <br>

#### [Stack - Mono stack-Histogram Problems]()
TODO:84.Largest Rectangle in Histogram (H)
TODO:85.(H)
TODO:1504.

#### [Stack - Mono stack-Pre-caculate 左/右比自己大/小的idx ]()
TODO:907

#### [Stack - Mono stack-Get Max Lexicographical Order]()
TODO:316
TODO:321

### [Queue]
TODO:995(H)

### [哈希]()

#### [Hashmap/Dictionary]()
数组 O(k的size)
支持操作:O(1) Insert / O(1) Find / O(1) Delete  (真的是O(1)吗？key的size有关系)

Hash Function 使命:对于任意的key 得到一个固定且无规律的介于0~capacity-1的整数
著名的hash算法：MD5, SHA-1, SHA-2
Hash Table:线程安全的hash，同时做好几件事情，都不会崩掉
Hash Map:存key-value
Hash Set:只存key
存在冲突的两种解决办法：Open Hashing（占用别人的位置） vs Closed Hashing（链表连起来）
hash不够大时：Rehashing   <br>
 
解题思路：将list作为key放入dict会报错!解决办法：讲list转成tuple，在使用map.将什么定义成key?
什么能区分不同的group, 就将什么定义成key.
- [0049.Group_Anagrams.py](Solutions/0049.Group_Anagrams.py) (!!M)<br>
- [0249.Group_Shifted_Strings.py](Solutions/0249.Group_Shifted_Strings.py) (!!M Google) <br>
- [0366.Find_Leaves_of_Binary_Tree.py](Solutions/0366.Find_Leaves_of_Binary_Tree.py) (!!M)<br>
  将leaf node的level定义为0，临接的node的level定义为1，使用dfs遍历tree，得到所有结点的level，将level，num存入dict中，   就可以得到结果
- [0166.Fraction_to_Recurring_Decimal.py](Solutions/0166.Fraction_to_Recurring_Decimal.py) (!!M)<br>
  166:思路很秒，将reminder, pos存入dict中，每次做除法之前在dict中查找是否已经有了，如果有直接取出pos到当前pos，然后退出。   如果没有如果reminder ==   0 退出，否则一直做除法。
- [0652.Find_Duplicate_Subtrees.py](Solutions/0652.Find_Duplicate_Subtrees.py) (M)<br>
- [1296.Divide_Array_in_Sets_of_K_Consecutive_Numbers.py](Solutions/1296.Divide_Array_in_Sets_of_K_Consecutive_Numbers.py) (M)<br>
- [0659.Split_Array_into_Consecutive_Subsequences.py](Solutions/0659.Split_Array_into_Consecutive_Subsequences.py) (M)<br>
- [0706.Design_HashMap.py](Solutions/0706.Design_HashMap.py) (E)<br>
  新建一个class用于存储key, value, 以及next, 链表

OrderedDict用法:
- [0146.LRU_Cache.py](Solutions/0146.LRU_Cache.py) (!!!M youtubed) <br>
  1. 使用queue去存储最近访问过的key  2. cache去存储key, value  3. get后要更新q  4. put时如果capacity已经不足，要删除最近最久没使用的值
- [0460.LFU_Cache.py](Solutions/0460.LFU_Cache.py) (H) <br>
  1.好的思路是用2个dict去存，key->freq and freq -> (key, value),以及要存储最小频率
  因为我们既要根据key查freq,又要根据freq查key,注意题目中很多细节问题
  所有的操作都是围绕：1. update key_to_freq 2. update freq_to_orddict 3. update min_freq if needed
 TODO:895(H)

- [0129.Rehashing](Solutions/0129.Rehashing.java) (lintcode)  <br>
- [0138.Subarray Sum](Solutions/0138.Subarray_Sum.py) (lintcode) <br>
  复习这2个！！

- [0138.Copy List with Random Pointer](Solutions/0138.Copy_List_with_Random_Pointer.py)  <br>
  Solution 1 O(N), O(N): Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from   multiple nodes due to the random pointers, make sure you are not making multiple copies of the same node. we can use extra space   to keep old node --> new node mapping to prevent creating multiples copies of same node.
- [0242.Valid Anagram](Solutions/0242.Valid_Anagram.py)  <br>
  string s and t are anagram with each other when all the ch in s have the same count as that in t. Counter(s) and Counter(t)
- [0128.Longest Consecutive Sequence](Solutions/0128.Longest_Consecutive_Sequence.py)  <br>
  使用一个集合hashset存入所有的数字，然后遍历数组中的每个数字，如果其在集合中存在，那就将其移除，然后分别用两个变量prev和next算出其前一个跟后一个数。
  注意：找到后要删除set中的数，因为没有必要再重复的寻找最大的连续序列，例如4231，找了4的最大连续序列，就不用再找了
- [0953.Verifying_an_Alien_Dictionary](Solutions/0953.Verifying_an_Alien_Dictionary.py)  (!!M Facebook) <br>
  hashmap存 the position of ch in the list（idx, character）. we traverse the words list and check adjacent word.
- [0535.Encode_and_Decode_TinyURL.py](Solutions/0535.Encode_and_Decode_TinyURL.py) (M Google)<br>
  Convert long url to short url via hashing. Look up long url from short url in hash table. # hash(str) returns the             hash_code for the str.用一个mapping去存储长短连接之间的对应关系，长短连接的转换用hash去做。hash(str) returns the hash_code for the     str.注意hash(str)返回的结果是int
- [1146.Snapshot_Array.py](Solutions/1146.Snapshot_Array.py) (!!!!!!!M Google)<br>
  store data snapshot, first we need a array to store the snapshot, and we need a dict to store data.
- [1400.Construct_K_Palindrome_Strings.py](Solutions/1400.Construct_K_Palindrome_Strings.py) (!!M)<br>
  It is a trick algoritm: we only need to count the sum of number which has odd cnt. Ex. a=3，b=5, so k >= 2 because last a and b can not exist in same palindrome
  
#### [Hashset]()
- [0705.Design_HashSet.py](Solutions/0705.Design_HashSet.py) (E) <br>
TODO:710(H)

### [堆 heap & PriorityQueue]()
**实际上是二叉树，实现时可以用数组去存储, sink down, swimm up**
支持操作: 堆支持快速的删除任意一个节点
O(log N) Add：插入在堆的最右边最下层的位置，然后不断的向上调整，所以是logN
O(log N) Remove：需要在logn时删除，需要hashmap，key存储区别每个节点的值，value是在堆里的位置，需要先知道位置后，才能快速删除：将在堆的最右边最下层的位置的值和最顶上的值交换，然后最顶上的值像下调整，与两个儿子中最小的交换
O(1) Min or Max Max Heap vs Min Heap : 因为顶上的点就是最小值

**Java Version:**
PriorityQueue（Java-从小到大） vs Heap关系：
PriorityQueue是用heap实现的，heap是数据结构角度说的名词，PriorityQueue是从类的角度说的，包装好了一个工具，本质是一个堆。但是没有实现堆的所有功能。
PriorityQueue一定要用这个数据结构，面试会考，不是Queue，只是具有Q的接口.
priorityQueue的方法有：
删除操作会循环一遍，所以是O(n) delete()//remove()区别于pop()
取heap的大小：size()
插入heap：offer()
取heap顶部元素：peek()  
取heap顶部元素：poll()

priorityQueue中为HashMap元素，怎么根据map的value进行排序？生成小顶堆：
Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）
PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>((a,b) -> a.getValue()==b.getValue() ? a.getKey().compareTo(b.getKey()) : a.getValue()-b.getValue());

**Python Version Remember:**
1.对已有array堆化: heapify(nums) Time:O(NlogN)  默认小顶堆，每次删除最小的值，所以求第K大的值最简单
2.一个个堆化：q=[] heappush(q, val)
heappop(nums) O(logN)   默认小顶堆，pop the smallest value
heappushpop(a, x) pushes x onto a before popping the smallest value
heappush(nums, val) O(logN)  默认小顶堆
len(nums)
heapify为tuple时，先按照num1小顶堆，再按照num2小顶堆

**Heapify and Heap Sort**
把一个数组变成堆:很随意的二叉树变成堆的样子:小的在上面，全局最上面为最小的   时间复杂度：O(N) // O(NlogN)
heapify是堆排序的一个步骤，heapify是建立堆的过程. heapify时间复杂度O(n)
堆排序是：建立堆+排序  
堆排序时间复杂度是：O(n + nlogn) = nlogn

#### [PriorityQueue]()
Heapq的应用： <br>
1.Top K problem - top K largest/smallest/frequent  <br>
2.Data stream - dynamic situations where large numbers of insertion/remove/query the maximum/minimum operations are intermixed <br>
3.Best first search in graph - Dijkstra’s and A*  <br>
  
**Heapq1应用：Top K problem - top K largest/smallest/frequent**
1.nlogn方法：适合求Kth largest number
根据num初始化小顶堆，pop出n-k O(nlogn)
根据-num初始化大顶堆，get 0-n-1个元素  (nlogn)
初始化最小堆，pop出K个 klogn
2.nlogK方法：可以有序输出所有topK largest number.
K个最大的 先push，如果>k，pop出最小的，复杂度：(n-k)logk
K个最小的 -num，进行堆化，先push再出

- [0130.Heapify.java](Solutions/0130.Heapify.java) (M)<br>
  参考文档：
  https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/DemoHeapify.pdf
  http://www.jiuzhang.com/solutions/heapify/
  
- [0703.Kth Largest Element in a Stream](Solutions/0703.Kth_Largest_Element_in_a_Stream.py) (E)<br>
  maintain a min heap with k size. when initialize, we need heapify it and keep a k size. Then add it, keep a k size.
  Always Error: heapify(nums), heappop(nums), heappush(nums, val)
- [0215.Kth Largest Element in an Array](Solutions/0215.Kth_Largest_Element_in_an_Array.py) (!!!M)<br>
  maintain a min heap with k size.Directly use heapify(num).then pop().
  time: O(NlogN + (N-K)logN), N 来自于for循环，logK来自于heap的长度是K，heap 的push 和pop都是logN
  heapq适合做第K大，第K小，前K大，前K小问题"""
- [0347.Top K Frequent Elements](Solutions/0347.Top_K_Frequent_Elements.py)(!!M) <br>
  K frequent element: need a min heap and size is k, if size larger than k, pop from heap. heappop() vs heappushpop(),         heappop() delete the min value. heappushpop() insert a val before delete the min val.
- [0692.Top_K_Frequent_Words](Solutions/0692.Top_K_Frequent_Words.py)(!!M) <br>
  solution same as 347，the only diff is K sort base on character when count same.
- [0973.K_Closest_Points_to_Origin](Solutions/0973.K_Closest_Points_to_Origin.py)(M) <br>
  Heapify (dis, point), then heapify, get k result.
- [0658.Find_K_Closest_Elements](Solutions/0658.Find_K_Closest_Elements.py)(M) <br>
  Heapify base on distance, and pop k num, and sort result array.

**Heapq1应用：Top K problem - Merge k Sorted Lists**
- [0023.Merge_k_Sorted_Lists](Solutions/0023.Merge_k_Sorted_Lists.py)(!!H) <br>
  solution1：放入一个数组，然后排序 NlogN N为个数
  solution2：heap做 NlogK N为元素个数，heap排序 O(log N),也可以用于array的合并.
  time:nklogk   space:k. First put all head to heap, Then pop the min value. if min value next not in heap, put it in heap.
  https://www.youtube.com/watch?v=XqA8bBoEdIY
  solution3: divide and conque
  注意：__lt__()方法重写，用于比较listnode 
- [0378.Kth_Smallest_Element_in_a_Sorted_Matrix](Solutions/0378.Kth_Smallest_Element_in_a_Sorted_Matrix.py)(!!M) <br>
  solution 1.brute force 变成1D, 排序 ->N^2*logN
  solution 2.将2d变成1d, 参考0215  ->N^2*logK  比方法1小一点
  solution 3. 对于任意一个位置(i,j),我们知道(1+1，j),(i, j + 1) 一定比当前数大，展开搜索BFS
  起点：(0,0) 每次展开最小值. 利用sorted matrix的性质，从左上角第一个元素开始，添加进heap，然后heap当然自动排序了，然后pop出最小的，然后把最小   的那个数的右边和下边的元素分别入heap，这样可以保证每次pop出来的都是最小的。
  O(Klog(K) 参考：https://www.youtube.com/watch?v=Lo23qFLhJNY 
- [1423.Maximum_Points_You_Can_Obtain_from_Cards.py](Solutions/1423.Maximum_Points_You_Can_Obtain_from_Cards.py)(E) <br>
  Each time you only can get a num from the beginning or the ending.Solution: calculation the splipper window, size is n-k,     get the minum value, so we can get maximum score.<br>
  follow up要用heap
  
**Heapq1应用：Top K problem - Task Schedule**
- [0621.Task_Scheduler](Solutions/0621.Task_Scheduler.py)(!!M) <br>
  根据频率得到最大堆maxHeap，q用于存储（-cnt, idleTime), pop后判断count个数，然后将（count，time）入栈。将q中time等于当前时间的入heap.
- 767
- 358
- 1405

**Heapq2应用：Dynamic insert/remove/query the maximum/minimum in Data Stream**
295

**Heapq3应用：Greedy**
1642

**SortedList - Could it be an even stronger heapq?**
480

- [1086.High_Five](Solutions/1086.High_Five.py)(M) <br>

### [Ugly Number]()
- [0263.Ugly_Number.py](Solutions/0263.Ugly_Number.py)(E) <br>
- [0264.Ugly_Number_II.py](Solutions/0264.Ugly_Number_II.py)(M) 相当于BFS的解法<br>
- [0313.Super_Ugly_Number](Solutions/0313.Super_Ugly_Number.py)(M) <br>
  第 264 题的方法包括最小堆和动态规划。由于这道题的数据规模较大，因此最小堆的解法会超时，此处只提供动态规划的解法。 <br>
  解法1：最小堆 维护min{dp[i] * 2, dp[j] * 3, dp[k] * 5...}  超时 <br>
  解法2：动态规划   <br>

### [TreeMap]()
又想知道最小值，又想支持修改和删除 
https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html
http://www.lintcode.com/problem/building-outline/
692为啥可以用treemap?

TODO + Iterator
621
