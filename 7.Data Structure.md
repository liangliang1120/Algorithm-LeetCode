## [第七课：数据结构 Data Structure]()

### [Stack栈 and queue队列]()
队列 queue：
支持操作:O(1) Push / O(1) Pop / O(1) Top  
BFS的主要数据结构 多做做BFS的题就可以了
BFS的主要数据结构是 Queue // DFS 的主要数据结构是 Stack 

栈 stack：
数组//链表 支持操作:O(1) Push / O(1) Pop / O(1) Top 
非递归实现DFS的主要数据结构
- [Expression Expand](Solutions/111) 没找到题目  TODO <br>
- [0232.Implement Queue using Stacks](Solutions/232.Implement_Queue_using_Stacks)(E)  <br>
- [0225.Implement Stack using Queues](Solutions/0225.Implement_Stack_using_Queues.java) (E) <br>

#### [Stack - Parentheses problems]()
- [0020.Valid_Parentheses.py](Solutions/0020.Valid_Parentheses.py)(!!E) <br>
- [0921.Minimum_Add_to_Make_Parentheses_Valid.py](Solutions/0921.Minimum_Add_to_Make_Parentheses_Valid.py) (!!M) <br>
- [1047.Remove_All_Adjacent_Duplicates_In_String.py](Solutions/1047.Remove_All_Adjacent_Duplicates_In_String.py)(!!E) <br>
- [1209.Remove_All_Adjacent_Duplicates_in_String_II.py](Solutions/1209.Remove_All_Adjacent_Duplicates_in_String_II.py)(M) <br>
- [1249.Minimum_Remove_to_Make_Valid_Parentheses.py](Solutions/1249.Minimum_Remove_to_Make_Valid_Parentheses.py)(M) <br>
- [0856.Score_of_Parentheses.py](Solutions/0856.Score_of_Parentheses.py)(!!M) <br>
- [0394.Decode_String.py](Solutions/0394.Decode_String.py)(!!M Google) <br>
- [0346.Moving_Average_from_Data_Stream.py](Solutions/0346.Moving_Average_from_Data_Stream.py) (!!E Google) <br>
- [0946.Validate_Stack_Sequences.py](Solutions/0946.Validate_Stack_Sequences.py)  (!!!M Google)<br>
- [0716.Max Stack](Solutions/0716.Max_Stack.py) (E) <br>
- [0155.Min Stack](Solutions/0155.Min_Stack.py) (!!E) <br>

TODO:
Largest Rectangle in Histogram (hard) 单调栈: http://www.lintcode.com/en/problem/largest-rectangle-in-histogram/ <br>
Maximal Rectangle  (hard) http://www.lintcode.com/problem/maximal-rectangle/ <br>
Max Tree  (hard) http://www.lintcode.com/problem/max-tree/ <br>

Iterator:  主程序在next中实现，hasNext()
Flatten Nested List Iterator
http://www.lintcode.com/problem/flatten-nested-list-iterator
http://www.jiuzhang.com/solutions/flatten-nested-list-iterator/
http://www.lintcode.com/problem/binary-search-tree-iterator/
http://www.lintcode.com/problem/zigzag-iterator/ 
http://www.lintcode.com/problem/zigzag-iterator-ii/ 
http://www.lintcode.com/problem/flatten-2d-vector/

### [哈希表 hash Hashmap]()
数组 O(k的size)
支持操作:O(1) Insert / O(1) Find / O(1) Delete  (真的是O(1)吗？key的size有关系)

Hash Function 使命:对于任意的key 得到一个固定且无规律的介于0~capacity-1的整数
著名的hash算法：MD5, SHA-1, SHA-2
Hash Table:线程安全的hash，同时做好几件事情，都不会崩掉
Hash Map:存key-value
Hash Set:只存key
存在冲突的两种解决办法：Open Hashing（占用别人的位置） vs Closed Hashing（链表连起来）
hash不够大时：Rehashing   <br>

- [0129.Rehashing](Solutions/0129.Rehashing.java) (lintcode)  <br>
- [0146.LRU_Cache.py](Solutions/0146.LRU_Cache.py) (!!!M youtubed) <br>
- [0146.LRU Cache](Solutions/0146.LRU_Cache.java)  <br>
- [0138.Subarray Sum](Solutions/0138.Subarray_Sum.java)  <br>
- [0138.Copy List with Random Pointer](Solutions/0138.Copy_List_with_Random_Pointer.java)  <br>
- [0242.Valid Anagram](Solutions/0242.Valid_Anagram.java)  <br>
- [0128.Longest Consecutive Sequence.](Solutions/0128.Longest_Consecutive_Sequence.java)  <br>
- [0953.Verifying_an_Alien_Dictionary.py](Solutions/0953.Verifying_an_Alien_Dictionary.py)  (!!M Facebook) <br>
- [0249.Group_Shifted_Strings.py](Solutions/0249.Group_Shifted_Strings.py) (!!M Google) <br>
- [0049.Group_Anagrams.py](Solutions/0049.Group_Anagrams.py) (!!M)<br>
- [0535.Encode_and_Decode_TinyURL.py](Solutions/0535.Encode_and_Decode_TinyURL.py) (M Google)<br>
- [1146.Snapshot_Array.py](Solutions/1146.Snapshot_Array.py) (!!!!!!!M Google)<br>
- [1400.Construct_K_Palindrome_Strings.py](Solutions/1400.Construct_K_Palindrome_Strings.py) (!!M)<br>

### [堆 heap & PriorityQueue]()
**实际上是二叉树，实现时可以用数组去存储, sink down, swimm up**
支持操作: 堆支持快速的删除任意一个节点

O(log N) Add：插入在堆的最右边最下层的位置，然后不断的向上调整，所以是logN
O(log N) Remove：需要在logn时删除，需要hashmap，key存储区别每个节点的值，value是在堆里的位置，需要先知道位置后，才能快速删除：将在堆的最右边最下层的位置的值和最顶上的值交换，然后最顶上的值像下调整，与两个儿子中最小的交换
O(1) Min or Max Max Heap vs Min Heap : 因为顶上的点就是最小值

PriorityQueue（Java-从小到大） vs Heap关系：
PriorityQueue是用heap实现的，heap是数据结构角度说的名词，PriorityQueue是从类的角度说的，包装好了一个工具，本质是一个堆。但是没有实现堆的所有功能。
PriorityQueue一定要用这个数据结构，面试会考，不是Queue，只是具有Q的接口.
priorityQueue的方法有：
删除操作会循环一遍，所以是O(n) delete()//remove()区别于pop()
取heap的大小：size()
插入heap：offer()
取heap顶部元素：peek()  
取heap顶部元素：poll()

priorityQueue中为HashMap元素，怎么根据map的value进行排序？生成小顶堆：
Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry<K,V>。它表示Map中的一个实体（一个key-value对）
PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>((a,b) -> a.getValue()==b.getValue() ? a.getKey().compareTo(b.getKey()) : a.getValue()-b.getValue());

#### [Heapify]()
把一个数组变成堆:很随意的二叉树变成堆的样子:小的在上面，全局最上面为最小的   时间复杂度：O(N) // O(NlogN)
- [0130.Heapify.java](Solutions/0130.Heapify.java) (M)<br>
参考文档：https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/DemoHeapify.pdf
http://www.jiuzhang.com/solutions/heapify/

heapify是堆排序的一个步骤，heapify是建立堆的过程. heapify时间复杂度O(n)
堆排序是：建立堆+排序  
堆排序时间复杂度是：O(n + nlogn) = nlogn

#### [PriorityQueue]()
- [0703.Kth Largest Element in a Stream](Solutions/0703.Kth_Largest_Element_in_a_Stream.java) (E)<br>
- [0215.Kth Largest Element in an Array](Solutions/0215.Kth_Largest_Element_in_an_Array.java) (!!!M)<br>
- [0378.Kth_Smallest_Element_in_a_Sorted_Matrix.py](Solutions/0378.Kth_Smallest_Element_in_a_Sorted_Matrix.py) (!!M)<br>
- [0347.Top K Frequent Elements](Solutions/0347.Top_K_Frequent_Elements.java)(!!M) <br>
- [0692.Top_K_Frequent_Words.py](Solutions/0692.Top_K_Frequent_Words.py)(!!M) <br>
- [0973.K_Closest_Points_to_Origin.py](Solutions/0973.K_Closest_Points_to_Origin.py)(M) <br>
- [0658.Find_K_Closest_Elements.py](Solutions/0658.Find_K_Closest_Elements.py)(M) <br>
- [0621.Task_Scheduler.py](Solutions/0621.Task_Scheduler.py)(!!M) <br>
- [0023.Merge_k_Sorted_Lists.py](Solutions/0023.Merge_k_Sorted_Lists.py)(!!H) <br>

 http://www.lintcode.com/en/problem/high-five/ (A)
• http://www.lintcode.com/en/problem/k-closest-points/ (L, A, F)
• http://www.lintcode.com/problem/merge-k-sorted-arrays/
• http://www.lintcode.com/problem/data-stream-median/
• http://www.lintcode.com/problem/kth-smallest-number-in-sorted-matrix/

### [Ugly Number]()
- [0263.Ugly_Number.py](Solutions/0263.Ugly_Number.py)(E) <br>
- [0264.Ugly_Number_II.py](Solutions/0264.Ugly_Number_II.py)(M) 相当于BFS的解法<br>
  313. Super Ugly Number (M)         TODO:不会写
  解法1：用BFS解法会超时 NKlogNK
  解法2：维护min{dp[i] * 2, dp[j] * 3, dp[k] * 5}

### [TreeMap]()
又想知道最小值，又想支持修改和删除 
https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html
http://www.lintcode.com/problem/building-outline/
692为啥可以用treemap?

有问题：
1249 856 394
TODO + Iterator
