## [第八课：动态规划 Dynamic Programming]()
DP四要素：<br>
1.定义状态： dp[i][j]的意义  最后一步  化成子问题<br>
2.返回什么东西<br>
3.初始化  初始化一个二维的动态规划时 就去初始化第0行和第0列 和 边界情况 <br>
4.递推公式：怎么从初始化里面推测想返回的值<br>

总体来说DP的两种写法：<br>
1. 记忆化搜索方式：自上而下：DFS+Memoriztion   (todo 等DFS刷完了就知道了)<br>
2. 多重循环：traditional 写法：定义数组记录状态 两种实现没有区别，思维模式一个正向，一个逆向<br>
   自下而上  自上而下<br>

什么情况下使用动态规划?<br>
满足下面三个条件之一，则 极有可能 是使用动态规划求解: <br>
• 统计方案个数 ：1.有多少中方式走到右下角  2.有多少中方法选出K个数使得和是sum      运算：+  <br>
• 求最大值最小值：1.从左上角走到右下角路径的最大数字和  2.最长上升子序列长度        运算：min max  <br>
• 判断是否可行  1.取石子游戏，先手是否必胜  2.能不能选出k个数使得和是Sum          运算：and or <br>

什么时候不用动态规划？<br>
• 所有方案而不是方案数 （递归+深度搜索）<br>
• 集合而非序列<br>
• 暴力算法已经是多项式级别复杂度<br>
    动态规划擅长优化指数级别(2^n)到多项式级别(n^2)<br>

动态规划 vs 递归???  <br>
递归：从上到下，然后会很多重复计算，时间复杂度为指数型  <br>
动态规划：从下到上，用数组记录下来值，简化时间复杂度。  <br>

动态规划 vs 贪心算法？？？ <br>
贪心算法是每一步都用最优解法，例如，硬币问题，第一步就用最大硬币，第一步就可能走遍。 <br>
动态规划是选取最优解  <br>

### [1.坐标型DP]()
i个数：a[0], a[1], ..., a[i-1]
给定输入为序列或者网格/矩阵
动态规划状态下标为序列下标i或者网格坐标（i，j）
   f[i]以a[i]结尾的某种性质   求f[n]
   f[i][j] 到坐标（i，j）的路径的性质   求f[m-1][n-1]  
初始化设置f[0]的值、f[0][0...n-1]的值
二维空间优化：如果f[i][j]的值值依赖于当前行和前一行，则可以用滚动数组节省空间

延伸：滚动数组（经常用于坐标型DP）+打印路径（要记录用的路径）结合？？？TODO没懂 第三讲

最简单的动态规划类型，给定一个序列或网格
- [0062.Unique Paths](Solutions/0062.Unique_Paths.java)  (!!M) <br>
- [0063.Unique Paths II](Solutions/0063.Unique_Paths_II.java) (M)<br>
- [0064.Minimum Path Sum](Solutions/0064.Minimum_Path_Sum.java) (M)  方法一：dp, 方法二：空间优化  延伸题目：求路径 <br>
- [0361.Bomb_Enemy.py](Solutions/0361.Bomb_Enemy.py) (M)
- [0120.Triangle](Solutions/0120.Triangle.java) (M) <br>  
  • DFS: Traverse • DFS: Divide Conquer • Divide Conquer + Memorization • Traditional Dynamic Programming
- [0070.Climbing Stairs](Solutions/0070.Climbing_Stairs.java) (E) <br>
- [0746.Min Cost Climbing Stairs](Solutions/0746.Min_Cost_Climbing_Stairs.java) (E) <br>

跳跃游戏 I && II  这个题最优的方法是使用“贪心法”，动态规划复杂度较高
- [0055.Jump Game.java](Solutions/0055.Jump_Game.java) TODO:贪心算法 <br>     
- [0045.Jump_Game II](Solutions/0045.Jump_Game_II.java)  <br>

#### [最长序列型DP]()
 i个数：a[0], a[1], ..., a[i-1]...a[n-1]
 其实是坐标型动态规划，并不是序列型动态规划
 dp[i]都是定义以a[i]结尾的最长... dp = [n]  求dp[n]   
 Note: subarray/substring 必须连续，subsequence/subsets 不需要连续  

- [0674.Longest Continuous Increasing Subsequence](Solutions/0674.Longest_Continuous_Increasing_Subsequence.py) (E) <br>
- [0300.Longest Increasing Subsequence](Solutions/0300.Longest_Increasing_Subsequence.py) (!!!M) <br>
  solution1: tradition dp O(N*N)
  solution2: 时间复杂度优化
  
- [0673.Number_of_Longest_Increasing_Subsequence](Solutions/0673.Number_of_Longest_Increasing_Subsequence.py) (!!M) <br>

- [0279.Perfect Squares](Solutions/0279.Perfect_Squares.java) (!!M) <br>
  f[j]=the least number of perfect square numbers which sum to i; f[j] = min(f[j-i^2]+1) for i^2<=j; Time complexity: j is from 0 to n, i is from 0 to j^0.5, so O(N^1.5); solution 2: level order BFS. Given a N-ary tree, where each node represents a remainder of the number n subtracting a square number, our task is to find a node in the tree, which should meet the conditions or remainder=0. bfs的层数就代表了所需要perfect squares的个数. Time complexity: 比较复杂最后是 O(n^(h/2)), where h is the height of the N-ary tree, h is 0 to 4.
  
- [0354.Russian_Doll_Envelopes](Solutions/0354.Russian_Doll_Envelopes.py) (H)<br>
- [0368.Largest_Divisible_Subset](Solutions/0368.Largest_Divisible_Subset.py) (M)<br>

TODO：
403. Frog Jump (H)  

### [2.位操作动态规划]()
&与 |或  ^异或  ！非 
逐位操作
- [0338.Counting_Bits.py](Solutions/0338.Counting_Bits.py) (E) <br>

### [3.序列型DP]()
序列型特点：前i个，最小、方式数、可行性   <br>

序列型和坐标型区别：<br>
1.给定一个序列 <br>
动态规划方程f[i]中的下标i表示前i个元素a[0], a[1], ..., a[i-1]的某种性质  <br>
坐标型的f[i]表示以a[i]为结尾的某种性质  <br>
2.初始化中，f[0]表示空序列的性质   <br>
– 坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质  <br>

序列+状态型动态规划：当思考动态规划最后一步时，这一步的选择依赖于前一步的某种状态  <br>

- [0256.Paint_House.py](Solutions/0256.Paint_House.py) (M) <br>
- [0265.Paint_House_II.py](Solutions/0265.Paint_House_II.py) (H) <br>
  首先可以按照常规的dp方法去解题，发现时间复杂度比较高 k*k*n，思考优化方法。提前计算优化复杂度为 k*n!!!<br>
- [0198.House_Robber.py](Solutions/0198.House_Robber.py) (E) <br>
- [0213.House_Robber_II.py](Solutions/0213.House_Robber_II.py) (!!M) <br>
- [0152.Maximum_Product_Subarray.py](Solutions/0152.Maximum_Product_Subarray.py) (!!M) <br>
- [0978.Longest_Turbulent_Subarray.py](Solutions/0978.Longest_Turbulent_Subarray.py) (!!M) <br>

#### [Buy and sell stock DP问题]()
- [0121.Best_Time_to_Buy_and_Sell_Stock](Solutions/0121.Best_Time_to_Buy_and_Sell_Stock.py) (E) <br>
- [0122.Best_Time_to_Buy_and_Sell_Stock_II](Solutions/0122.Best_Time_to_Buy_and_Sell_Stock_II.py) (M) <br>
- [0309.Best_Time_to_Buy_and_Sell_Stock_with_Cooldown](Solutions/0309.Best_Time_to_Buy_and_Sell_Stock_with_Cooldown.py
) (M) <br>
- [0714.Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee](Solutions/0714.Best_Time_to_Buy_and_Sell_Stock_with_Transaction_Fee.py) (M) <br>

TODO:
123 （H） <br>
188（H） <br>

### [4.划分型DP]()
特点：给定长度为N的序列或字符串，要求划分成若干段. 1.段数不限，或指定K段  2.每一段满足一定的性质  <br>
做法：  <br>
1.类似于序列型动态规划，但是通常要加上段数信息  <br>
2.一般用f[i][j]记录前i个元素（元素0~i-1）分成j段的性质，如最小代价  <br>

- [0091.Decode_Ways.py](Solutions/0091.Decode_Ways.py) (M) 解密数字串即划分成若干段数字，每段数字对应一个字母（partition，把一个完整的东西分成几段）<br> 
- [0139.Word_Break](Solutions/0139.Word_Break.py) (!!M) <br> 
- [0279.Perfect_Squares.py](Solutions/0279.Perfect_Squares.py) (!!M) <br> 
solution 2: level order BFS. Given a N-ary tree, where each node represents a remainder of the number n subtracting a square number, our    task is to find a node in the tree, which should meet the conditions or remainder=0. bfs的层数就代表了所需要perfect squares的个数. Time    complexity: 比较复杂最后是 O(n^(h/2)), where h is the height of the N-ary tree, h is 0 to 4.  
TODO：时间复杂度+solution2

### [5.博弈型DP]() 
博弈动态规划通常从第一步分析，而不是最后一步  <br>
– 因为局面越来越简单，石子数越来越少   <br>

- [0394.Coins_in_a_Line](Solutions/0394.Coins_in_a_Line.py) (M Lintcode) <br> 
- [0486.Predict_the_Winner](Solutions/0486.Predict_the_Winner.py) (M) <br> 
- [0877.Stone_Game](Solutions/0877.Stone_Game.py) (M) <br> 
- [1406.Stone_Game_III](Solutions/1406.Stone_Game_III.py) (H) <br> 

### [6.背包型DP]()
1. 背包问题的特点：题目要求加起来满足什么条件往往是背包； <br> 
2. 背包问题总重量一定要入状态！  <br> 
3. 如果list中的items不能重复利用，那么状态要定义为成二维：前i个item拼出m的个数/可能性/方法/性质;  <br> 
4. buffer layer  <br> 

• 你有一个背包，背包有最大承重c
• 商店里有若干物品，都是免费拿 <br> 
• 每个物品有重量和价值 <br> 
• 目标:不撑爆背包的前提下 <br> 
   – 装下最多重量物品 <br> 
   – 装下最大总价值的物品 <br> 
   – 有多少种方式正好带走满满一书包物品 <br> 

- [0322.Coin_Change](Solutions/0322.Coin_Change.py) (!!M) <br> 
  TODO : 0518. Coin Change 2 (M)
- [0092.Backpack](Solutions/0092.Backpack.py) (!!M Lintcode) <br> 
  要求不超过M时能拼出的最大重量, 记录前i个物品能拼出哪些重量
- [0125.Backpack_II](Solutions/0125.Backpack_II.py) (!!M Lintcode) <br> 
- [0563.Backpack_V](Solutions/0563.Backpack_V.py) (!!M Lintcode) <br> 
优化：滚动素组，m*n维数组，压缩成2维数组，再压缩成1维数组

377. Combination Sum IV (M)

### [7.区间型DP]()
给定一些序列/字符串，进行一些操作，求满足区间[i, j]的一些性质的题目   <br> 
自然而然将状态定义为f[i][j]表示面对子序列[i, j]时的最佳性质。  <br> 
经常用来处理sub-sequence, sub-string, sub-array的问题，  <br> 
注意sub-sequence不需要连续，sub-string, sub-array必须是连续的   <br> 

- [0005.Longest_Palindromic_Substring](Solutions/0005.Longest_Palindromic_Substring.py) (!!M) <br> 
- [0312.Burst_Balloons](Solutions/0312.Burst_Balloons.py) (H) <br> 
- [0375.Guess_Number_Higher_or_Lower_II](Solutions/0375.Guess_Number_Higher_or_Lower_II.py) (M) <br> 
TODO:471.
- [0516.Longest_Palindromic_Subsequence](Solutions/0516.Longest_Palindromic_Subsequence.py) (!!M) <br> 
- [0647.Palindromic_Substrings](Solutions/0647.Palindromic_Substrings.py) (!!M) <br> 

### [8.双序列型DP!!]()
72. Edit Distance/Levenshtein distance (!!H)
1143. Longest Common Subsequence (!!M)
0718. Maximum Length of Repeated Subarray 
583. Delete Operation for Two Strings (M)
1312
1092
97. Interleaving String (!!H)

use dp tabble to construct best path
1548
100320

dp的无后效性
62 
63
64
1537
329


其他类型动态规划
688

