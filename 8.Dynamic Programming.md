PPT上已经做完
## [第八课：动态规划 Dynamic Programming]()
DP四要素：<br>
1.定义状态： dp[i][j]的意义  最后一步  化成子问题<br>
2.返回什么东西<br>
3.初始化  初始化一个二维的动态规划时 就去初始化第0行和第0列 和 边界情况 <br>
4.递推公式：怎么从初始化里面推测想返回的值<br>

总体来说DP的两种写法：<br>
1. 记忆化搜索方式：自上而下：DFS+Memoriztion   (todo 等DFS刷完了就知道了)<br>
2. 多重循环：traditional 写法：定义数组记录状态 两种实现没有区别，思维模式一个正向，一个逆向<br>
   自下而上  自上而下<br>

什么情况下使用动态规划?<br>
满足下面三个条件之一，则 极有可能 是使用动态规划求解: <br>
• 统计方案个数 ：1.有多少中方式走到右下角  2.有多少中方法选出K个数使得和是sum   运算：+  <br>
• 求最大值最小值：1.从左上角走到右下角路径的最大数字和  2.最长上升子序列长度  运算：min max  <br>
• 判断是否可行  1.取石子游戏，先手是否必胜  2.能不能选出k个数使得和是Sum  运算：and or <br>

什么时候不用动态规划？<br>
• 所有方案而不是方案数 （递归+深度搜索）<br>
• 集合而非序列<br>
• 暴力算法已经是多项式级别复杂度<br>
    动态规划擅长优化指数级别(2^n)到多项式级别(n^2)<br>

动态规划 vs 递归  ???
递归：从上到下，然后会很多重复计算，时间复杂度为指数型
动态规划：从下到上，用数组记录下来值，简化时间复杂度。

动态规划 vs 贪心算法  ？？？
贪心算法是每一步都用最优解法，例如，硬币问题，第一步就用最大硬币，第一步就可能走遍。
动态规划是选取最优解

Maximum product Subarray   todo

### [坐标型DP]()
最简单的动态规划类型，给定一个序列或网格
- [0062.Unique Paths](Solutions/0062.Unique_Paths.java)  (!!M) <br>
- [0063.Unique Paths II](Solutions/0063.Unique_Paths_II.java) (M)<br>
- [0064.Minimum Path Sum](Solutions/0064.Minimum_Path_Sum.java) (M)  方法一：dp, 方法二：空间优化  延伸题目：求路径 <br>
- [0361.Bomb_Enemy.py](Solutions/0361.Bomb_Enemy.py) (M)
- [0120.Triangle](Solutions/0120.Triangle.java) <br>  
  • DFS: Traverse • DFS: Divide Conquer • Divide Conquer + Memorization • Traditional Dynamic Programming
- [0070.Climbing Stairs](Solutions/0070.Climbing_Stairs.java) <br>
- [0746.Min Cost Climbing Stairs](Solutions/0746.Min_Cost_Climbing_Stairs.java) <br>

跳跃游戏 I && II  这个题最优的方法是使用“贪心法”，动态规划复杂度较高
- [0055.Jump Game.java](Solutions/0055.Jump_Game.java) TODO:贪心算法 <br>     
- [0045.Jump_Game II](Solutions/0045.Jump_Game_II.java)  <br>

### [位操作动态规划]()
&与 |或  ^异或  ！非 
逐位操作
- [0338.Counting_Bits.py](Solutions/0338.Counting_Bits.py) (E) <br>

#### [子序列型DP]()
- [0674.Longest Continuous Increasing Subsequence](Solution/0674.Longest_Continuous_Increasing_Subsequence.java) (E) <br>
  dp[i]都是定义以i结尾的最长...
  
300. Longest Increasing Subsequence (!!M)
673. Number of Longest Increasing Subsequence (!!M)

- [0300.Longest Increasing Subsequence](Solutions/0300.Longest_Increasing_Subsequence.java) (!!!M) <br>
- [0279.Perfect Squares](Solutions/0279.Perfect_Squares.java) <br>

Largest Divisible Subset  没懂！！！ 动态规划只能记录一种最优的方案  TODO:问一下Jimmy   
俄罗斯套娃 http://www.lintcode.com/en/problem/russian-doll-envelopes/   TODO
青蛙过河 http://www.lintcode.com/en/problem/frog-jump/   TODO

### [序列型DP]()
序列型：前I个，最小、方式数、可行性   
序列+状态

序列型和坐标型区别：
给定一个序列
动态规划方程f[i]中的下标I表示前I个元素a[0], a[1], ..., a[i-1]的某种性质
坐标型的f[i]表示以ai为结尾的某种性质

初始化中，f[0]表示空序列的性质
– 坐标型动态规划的初始条件f[0]就是指以a0为结尾的子序列的性质

- [0256.Paint_House.py](Solutions/0256.Paint_House.py) (M) <br>

978. Longest Turbulent Subarray (!!M)
198. House Robber (E)
213. House Robber II (!!M)
152. Maximum Product Subarray (!!M)

### [Buy and sell stock DP问题]()
121. Best Time to Buy and Sell Stock (E)
122. Best Time to Buy and Sell Stock II (E)
309. Best Time to Buy and Sell Stock with Cooldown (M)
714. Best Time to Buy and Sell Stock with Transaction Fee (M)

### [区间型DP]()
005. Longest Palindromic Substring (!!M)
647. Palindromic Substrings (!!M)
516. Longest Palindromic Subsequence (!!M)

### [划分型DP]()
解密数字串即华恩成若干段数字，每段数字对应一个字母
确定状态dp[i]前i个对应的，所以求的dp[n]

- [0091.Decode_Ways.py](Solutions/0091.Decode_Ways.py) (M) <br> 

139. Word Break (!!M)
279. Perfect Squares (!!M)

### [博弈型DP]()
0394. Coins in a Line (M Lintcode)
486. Predict the Winner (M)
877. Stone Game (!!M Google)

### [背包型DP]()
- [0322.Coin_Change.py](Solutions/0322.Coin_Change.py) (!!M) <br> 

0518. Coin Change 2 (M)
0092. Backpack (!!M Lintcode)
0563. Backpack-V (!!M Lintcode)
377. Combination Sum IV (M)
125. Backpack II (!!M Lintcode)

### [双序列型DP!!]()
1143. Longest Common Subsequence (!!M)
0718. Maximum Length of Repeated Subarray 
583. Delete Operation for Two Strings (M)
97. Interleaving String (!!H)
72. Edit Distance/Levenshtein distance (!!H)
