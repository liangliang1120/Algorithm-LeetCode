## [第五课：Linked List & Array 链表与数组](/Data-Structure.py) 

### [Linked List]()
a.Dummy Node <br>
如何使用 Dummy Node
head = dummy 这句话总是需要么? 
什么时候使用 Dummy Node? 结构变化，会导致头部变化，就可以用Dummy Node
Dummy Node 是否需要删除? 不用，Java会自动删除
使用 Dummy Node 算面试官会说我耗费了额外空间么? 
Dummy Node 非用不可么? 不是，写起来可能很麻烦
Dummy Node 初始化的值重要么?  不重要
链表的问题都需要用到 Dummy Node 么?  90%都可以用到
总结：链表的题一般就使用dummy node

1.Linked List Cycle  <br>
常规解法1：extra空间 用hashSet
非常规解法2：快慢指针  follow up:判断两个链表是不是有交集，并且求出相交点；
解法：两个链表连起来看有没有环，将一个链表的头尾相连，判断有没有环，有环说明是相交的，然后求出相交点。
先判断有没有交点：slow = fast = head slow每次走一步，fast每次走2步 
再求相交点：head slow分别出发，相遇点就是交点

2.求中点 <br>
slow = fast = head
slow = slow.next
fast = fast.next.next
最后slow是在中间或者中间偏右的

指针的题目特别注意有的地方要断开，有的地方链表已经变了
- [0206.Reverse Linked List.java](Solutions/0206.Reverse_Linked_List.java) (!!E)<br>
- [0092.Reverse_Linked_List_II.java](Solutions/0092.Reverse_Linked_List_II.java)  (M) TODO: onepass  <br>
- [0024.Swap_Nodes_in_Pairs.py](Solutions/0024.Swap_Nodes_in_Pairs.py)  (M) <br>
- [0021.Merge_Two_Sorted_Lists.py](Solutions/0021.Merge_Two_Sorted_Lists.py) (E) <br>
- [0086.Partition_List.py](Solutions/0086.Partition_List.py) (!!M) <br>
- [0141.Linked List Cycle](Solutions/0141.Linked_List_Cycle.java) (E) <br>
- [0142.Linked_List_Cycle_II.py](Solutions/0142.Linked_List_Cycle_II.py) (!!M) <br>

- [0160.Intersection of Two Linked Lists](Solutions/0160.Intersection_of_Two_Linked_Lists.java) (E) <br>
- [0234.Palindrome_Linked_List.py](Solutions/0234.Palindrome_Linked_List.py) (E) <br>
- [0002.Add_Two_Numbers.py](Solutions/0002.Add_Two_Numbers.py) (!!M) <br>
- [0445.Add_Two_Numbers_II.java](Solutions/0445.Add_Two_Numbers_II.java) (M) <br>

- [0025.Reverse Nodes in k-Group](Solutions/0025.Reverse_Nodes_in_k-Group.java)<br>
- [0138.Copy List with Random Pointer](Solutions/0138.Copy_List_with_Random_Pointer.java)<br>
 方法1：先复制点，再复制边，记录下来新老节点的映射关系，用hashMap存储。  缺点：用了额外的存储空间  （nextTime可以用下这个方法）<br>  
 方法2：记住，讨巧的方式，改变链表结构变成1-1’-2-2‘-3-3’ 再分离，不用额外的空间 <br>
 解题时：复杂问题先分成几个小问题，定好小问题的输入和输出，再写小问题 <br>

#### [Sorted List]()
- [0912.Sort an Array](Solutions/0912.Sort_an_Array.java)  可以用quick sort，也可以用merge sort<br>
- [0148.Sort_List.py](Solutions/0148.Sort_List.py) (!!M)   merge sort算法, 不能用quick sort，因为quick sort交换在list中很麻烦<br>
- TODO follow up???

heap也看小视频 
 
（TODO） 
http://www.lintcode.com/en/problem/swap-two-nodes-in-linked-list/ 
http://www.lintcode.com/en/problem/reorder-list/ 
http://www.lintcode.com/en/problem/rotate-list/

related:
http://www.lintcode.com/problem/convert-sorted-list-to-balanced-bst/
http://www.lintcode.com/problem/delete-node-in-the-middle-of-singly-linked-list/
http://www.lintcode.com/problem/convert-binary-search-tree-to-doubly-linked-list/

### [Array]()
子数组Subarray:令PrefixSum[i] = A[0] + A[1] + ... A[i - 1], PrefixSum[0] = 0。易知构造PrefixSum耗费O(n)时间和O(n)空间，如需计算子数组从下标i到下标j之间的所有数之和，则有 Sum(i~j) = PrefixSum[j + 1] - PrefixSum[i]
- [0053.Maximum Subarray](Solutions/0053.Maximum_Subarray.java)<br>
- [0604.Window Sum.java](Solutions/0604.Window_Sum.java)<br>
- [0138.Subarray Sum](Solutions/0138.Subarray_Sum.java) （lintcode）<br>

Subarray Sum Closest 求出来后排个序 （lintcode） TODO
http://www.lintcode.com/en/problem/subarray-sum-closest/
http://www.jiuzhang.com/solutions/subarray-sum-closest/
 
#### [Sorted Array]()
hash  time O(n+m)  space O(min(n,m))  一个数组放进去，另一个数组进行遍历在不在hash中  <br>
merge two sorted arrays  time O(nlogn + mlogm)  space O(1)  先把两个数组排序，再用两个指针遍历merge   <br>
Binary Search(n << m)  time O(nlogn + mlogn)  space O(1) 一个数组先排序，遍历另一个数组，查找在不在已经排好序的数组中，把小的数组排序，然后  for   循环大的数组   <br>

- [0006.Merge_Two_Sorted_Arrays.java](Solutions/0006.Merge_Two_Sorted_Arrays.java)  同0088 <br>
  follow up用binary search做
- [0088.Merge Sorted Array](Solutions/0088.Merge_Sorted_Array.java)  将小数组归并到大数组里，从后往前merge  <br> 
- http://www.lintcode.com/problem/intersection-of-two-arrays/ 两个数组的交 简单题应该会很多种方法  相关问题TODO <br> 
- [0004.Median_of_Two_Sorted_Arrays](Solutions/0004.Median_of_Two_Sorted_Arrays.java) <br>
   数组内积（点乘）  设计：数组index和value的形式，index相同的才乘起来。<br>
 
quick select!!!
kth largest element 从大到小第K个数 
median:掌握quick select 做法 logn ，等于kth largest element 
2个数组的中位数，就是合并后从小到大第k个数  
