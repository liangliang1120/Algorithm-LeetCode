## [第五课：Linked List & Array 链表与数组](/Data-Structure.py) 

### [Linked List]()
a.Dummy Node <br>
如何使用 Dummy Node
head = dummy 这句话总是需要么? 
什么时候使用 Dummy Node? 结构变化，会导致头部变化，就可以用Dummy Node
Dummy Node 是否需要删除? 不用，Java会自动删除
使用 Dummy Node 算面试官会说我耗费了额外空间么? 
Dummy Node 非用不可么? 不是，写起来可能很麻烦
Dummy Node 初始化的值重要么?  不重要
链表的问题都需要用到 Dummy Node 么?  90%都可以用到
总结：链表的题一般就使用dummy node

1.Linked List Cycle  <br>
常规解法1：extra空间 用hashSet
非常规解法2：快慢指针  follow up:判断两个链表是不是有交集，并且求出相交点；
解法：两个链表连起来看有没有环，将一个链表的头尾相连，判断有没有环，有环说明是相交的，然后求出相交点。
先判断有没有交点：slow = fast = head slow每次走一步，fast每次走2步 
再求相交点：head slow分别出发，相遇点就是交点

2.求中点 <br>
slow = fast = head
slow = slow.next
fast = fast.next.next
最后slow是在中间或者中间偏右的

指针的题目特别注意有的地方要断开，有的地方链表已经变了
- [0206.Reverse Linked List.java](Solutions/0206.Reverse_Linked_List.java) (!!E)<br>
- [0092.Reverse_Linked_List_II.java](Solutions/0092.Reverse_Linked_List_II.py)  (M) TODO: onepass  <br>
- [0024.Swap_Nodes_in_Pairs.py](Solutions/0024.Swap_Nodes_in_Pairs.py)  (M) <br>
- [0021.Merge_Two_Sorted_Lists.py](Solutions/0021.Merge_Two_Sorted_Lists.py) (E) <br>
- [0086.Partition_List.py](Solutions/0086.Partition_List.py) (!!M) <br>
- [0141.Linked List Cycle](Solutions/0141.Linked_List_Cycle.py) (E) <br>
- [0142.Linked_List_Cycle_II.py](Solutions/0142.Linked_List_Cycle_II.py) (!!M) <br>

- [0160.Intersection of Two Linked Lists](Solutions/0160.Intersection_of_Two_Linked_Lists.py) (E) <br>
- [0234.Palindrome_Linked_List.py](Solutions/0234.Palindrome_Linked_List.py) (E) <br>
- [0002.Add_Two_Numbers.py](Solutions/0002.Add_Two_Numbers.py) (!!M) solution: use carry bit.<br>
- [0445.Add_Two_Numbers_II.java](Solutions/0445.Add_Two_Numbers_II.py) (M) solution: reverse the list, then do exactly the same as 0002, then reverse again<br>

- [0025.Reverse Nodes in k-Group](Solutions/0025.Reverse_Nodes_in_k-Group.py) (H) <br>
- [0138.Copy List with Random Pointer](Solutions/0138.Copy_List_with_Random_Pointer.py) (M) <br>
 方法1：先复制点，再复制边，记录下来新老节点的映射关系，用hashMap存储。  缺点：用了额外的存储空间  （nextTime可以用下这个方法）<br>  
 方法2：记住，讨巧的方式，改变链表结构变成1-1’-2-2‘-3-3’ 再分离，不用额外的空间 <br>
 解题时：复杂问题先分成几个小问题，定好小问题的输入和输出，再写小问题 <br>

#### [Sorted List]()
- [0912.Sort an Array](Solutions/0912.Sort_an_Array.py) （M）  可以用quick sort，也可以用merge sort<br>
- [0148.Sort_List.py](Solutions/0148.Sort_List.py) (!!M)   merge sort算法, 不能用quick sort，因为quick sort交换在list中很麻烦, 注意找中点的时候，slow, fast = head, head.next。如果写成slow, fast = head, head会陷入死循环 <br>

（TODO） 
heap也看小视频 
http://www.lintcode.com/en/problem/swap-two-nodes-in-linked-list/ 
http://www.lintcode.com/en/problem/reorder-list/ 
http://www.lintcode.com/en/problem/rotate-list/
http://www.lintcode.com/problem/convert-sorted-list-to-balanced-bst/
http://www.lintcode.com/problem/delete-node-in-the-middle-of-singly-linked-list/
http://www.lintcode.com/problem/convert-binary-search-tree-to-doubly-linked-list/

### [Array Subarray相关问题]()
要点：子数组Subarray:令PrefixSum[i] = A[0] + A[1] + ... A[i - 1], PrefixSum[0] = 0。易知构造PrefixSum耗费O(n)时间和O(n)空间，如需计算子数组从下标i到下标j之间的所有数之和，则有 Sum(i~j) = PrefixSum[j + 1] - PrefixSum[i]    <br>

问：为什么需要一个 (0,0) 的初始 Pair?   <br>
答：我们首先需要回顾一下，在 subarray 这节课里，我们讲过一个重要的知识点，叫做 Prefix Sum    <br>
比如对于数组 [1,2,3,4]，他的 Prefix Sum 是 [1,3,6,10]   <br>
分别表示 前1个数之和，前2个数之和，前3个数之和，前4个数之和   <br>
这个时候如果你想要知道 子数组 从下标  1 到下标 2 的这一段的和(2+3)，就用前 3个数之和 减去 前1个数之和 = PrefixSum[2] - PrefixSum[0] = 6 - 1 = 5   <br>
你可以看到这里的 前 x 个数，和具体对应的下标之间，存在 +-1 的问题   <br>
第 x 个数的下标是 x - 1，反之 下标 x 是第 x + 1 个数   <br>
那么问题来了，如果要计算 下标从 0~2 这一段呢？也就是第1个数到第3个数，因为那样会访问到 PrefixSum[-1]   <br>
所以我们把 PrefixSum 整体往后面移动一位，把第0位空出来表示前0个数之和，也就是0. => [0,1,3,6,10]     <br>
那么此时就用 PrefixSum[3] - PrefixSum[0] ，这样计算就更方便了。   <br>
此时，PrefixSum[i] 代表 前i个数之和，也就是 下标区间在 0 ~ i-1 这一段的和   <br>

那么回过头来看看，为什么我们需要一个 (0,0) 的 pair 呢？  <br>
因为 这个 0,0 代表的就是前0个数之和为0    <br>
一个 n 个数的数组， 变成了 prefix Sum 数组之后，会多一个数出来   <br>

- [0053.Maximum Subarray](Solutions/0053.Maximum_Subarray.py)  <br>
- [0604.Window Sum](Solutions/0604.Window_Sum.py) (Lintcode) <br>
- [0138.Subarray Sum](Solutions/0138.Subarray_Sum.py) （lintcode）<br>
- [139.Subarray_Sum_Closest.py](Solutions/139.Subarray_Sum_Closest.py) （lintcode）(M) <br>
  Subarray Sum Closest 求出来后排个序  <br>
  讲解：http://www.jiuzhang.com/solutions/subarray-sum-closest/   <br>
 
#### [Sorted Array]()
hash  time O(n+m)  space O(min(n,m))  一个数组放进去，另一个数组进行遍历在不在hash中  <br>
merge two sorted arrays  time O(nlogn + mlogm)  space O(1)  先把两个数组排序，再用两个指针遍历merge   <br>
Binary Search(n << m)  time O(nlogn + mlogn)  space O(1) 一个数组先排序，遍历另一个数组，查找在不在已经排好序的数组中，把小的数组排序，然后  for   循环大的数组   <br>

- [0006.Merge_Two_Sorted_Arrays.java](Solutions/0006.Merge_Two_Sorted_Arrays.java)  同0088 <br>
  follow up用binary search做
- [0088.Merge Sorted Array](Solutions/0088.Merge_Sorted_Array.java)  将小数组归并到大数组里，从后往前merge  <br> 
- http://www.lintcode.com/problem/intersection-of-two-arrays/ 两个数组的交 简单题应该会很多种方法  相关问题TODO <br> 
- [0004.Median_of_Two_Sorted_Arrays](Solutions/0004.Median_of_Two_Sorted_Arrays.java) <br>
   数组内积（点乘）  设计：数组index和value的形式，index相同的才乘起来。<br>
 
quick select!!!
kth largest element 从大到小第K个数 
median:掌握quick select 做法 logn ，等于kth largest element 
2个数组的中位数，就是合并后从小到大第k个数  

0086  160
