## [第六课：Two Pointes 两根指针]()
一般适合时间复杂度要求是O（n）的

### [反向双指针]()
反向双指针的时间复杂度是O(N)。如果面试官对O(N^2)或者O(NlogN)的解法不满意，或者要求in-place modification, 那就可以考虑双指针方法。
反向双指针的两个应用：1.3-Sum 问题 2.Partition in quick sort or quick select  

- [0977.Squares_of_a_Sorted_Array.py](Solutions/0977.Squares_of_a_Sorted_Array.py) (E) <br>
- [0011.Container_With_Most_Water.py](Solutions/0011.Container_With_Most_Water.py)  (!!M)  <br>

#### [Two Sum]()
模板必记：可以循环其中一个变量，然后研究另外一个变量如何变化  <br>
1.哈希表(HashMap)，判断target-num在不在hashmap中，在的话，return true.适用于没排序。 <br>
2.两根指针(Two Pointers)，先排序，一个指针从前往后走，一个指针从后往前走。
3.如果没有说数组有没有重复，一定要记得去重。  <br>

- [0001.Two Sum](Solutions/0001.Two_Sum.py)(!!E) <br>  
  Solution: array没有排好序，不重复。对于求2个变量如何组合的问题可以循环其中一个变量，然后研究另外一个变量如何变化.普世的方法是：for循环一个变量a，然后看另外一个变量target-a是不是在一个hashmap中。method: a.hashmap 存<nums[i], i>   b.先排序[需要保存index] 低空间复杂度 two pointers  <br>
- [0167.Two Sum II Input Array Is Sorted](Solutions/0167.Two_Sum_II_Input_Array_Is_Sorted.py) (E)<br> 
  Solution: array排好序，不重复。使用Two Pointers更好, 且不需要额外的存储空间。O（T） = O（N） 
- [0170.Two_Sum_III_Data_structure_design](Solutions/0170.Two_Sum_III_Data_structure_design.py) (E) <br> 
  Solution: array求存不存在, 注意可能有重复。Data structure design 只能使用HashMap，数组大小固定不能添加新元素，所以不能用2根指针 <br>
- [0653.Two_Sum_IV-Input_is_a_BST.java](Solutions/0653.Two_Sum_IV-Input_is_a_BST.java) (E)  <br> 
  Solution: 注意输入是BST，in-order是从大到小，所以可以用2个指针.First, we need use inorder to get inorder array. Then user two point to solve the problem.
- [1214.Two_Sum_BSTs.py](Solutions/1214.Two_Sum_BSTs.py) (M)  <br> 
  Solution: Iteratively do an inorder traversal for root1, and store the val in a hashSet; then itteratively do an inorder traversal for root2, and at the same time check if a target-val is in the hashSet. time complexity: O(M + N). 算法跟two sum是一样的，如果闭着眼睛能写要会iterative in-order traversal的哈！1. hashset, 一边遍历一个array，一遍存入hashset中，然后遍历另一个array，一遍判断存不存在 2. in-order-traversal + 反向双指针：分别中序遍历2个array，然后反向双指针去判断。 3. brutal force。
- [1099.Two_Sum_Less_Than_K.py](Solutions/1099.Two_Sum_Less_Than_K.py) (E) <br> 
  Solution:小于K只能用双指针，记得先排序。
- [0609.Two_Sum-Less_than_or_equal_to_target.py](Solutions/0609.Two_Sum-Less_than_or_equal_to_target.py) (!!E Lintcode) <br> 
  Solution:类似1099题，不同在于要记录pair的个数
- [0043.Two_Sum-Greater_than_target.py](Solutions/0043.Two_Sum-Greater_than_target.py) (!!E Lintcode) <br> 
- [0533.Two Sum - Closest to target](Solutions/0533.Two_Sum-Closest_to_target.java) Two Sum Closest (lintcode)  <br>  
  Solution:类似609题，只是要记录距离target最接近的。大于或者小于都可以。
- [0587.Two_Sum-Unique_pairs.py](Solutions/0587.Two_Sum-Unique_pairs.py)  (!!M Lintcode)  <br> 
  Solution:找unique pair which sum equal to target. Unique pairs 是否可以先去重？不能. So we need record the last position. when sum is equal to target, we need check if the pos is equal to last pos, if it is same, skip it.
- [0012.Two_Sum-Difference_equals_to_target.py](Solutions/0012.Two_Sum-Difference_equals_to_target.py) (lintcode)  <br>
  Sulotion: 只能同向双指针做   

#### [3 Sum & 4 Sum]()
- [0015.3Sum](Solutions/0015.3Sum.java)  (!!M) 3Sum  统计所有的和为0的三元组（Triples） <br>  
- [0016.3Sum Closest](Solutions/0016.3Sum_Closest.java) (M) 3Sum Closest <br>   
- [0259.3Sum_Smaller.py](Solutions/0259.3Sum_Smaller.py) (M)  <br>   
- [0018.4Sum.py](Solutions/0018.4Sum.py) (M)  <br>   
- [0454.4Sum_II.py](Solutions/0454.4Sum_II.py) (M)  <br>   
- 89 k-Sum

### [quick sort + merge sort]()
- [0912.Sort an Array](Solutions/0912.Sort_an_Array.py)  <br>
  quick sort // merge sort
- [0215.Kth_Largest_Element_in_an_Array](Solutions/0215.Kth_Largest_Element_in_an_Array.py)  <br>
  Quick Select 利用快速排序  
  partition 也是快速排序中的一个步骤

### [partition]()
- [0031.Partition Array](Solutions/0031.Partition_Array.py) （lintcode）注意：4个地方的判断语序写成一样的  <br>
- [0373.Partition_Array_by_Odd_and_Even.py](Solutions/0373.Partition_Array_by_Odd_and_Even.py) (LintCode)<br>
- [0144.Interleaving_Positive_and_Negative_Numbers.py](Solutions/0144.Interleaving_Positive_and_Negative_Numbers.py) (LintCode)<br>
- [0049.Sort_Letters_by_Case.py](Solutions/0049.Sort_Letters_by_Case.py) (LintCode)<br>
- [0075.Sort Colors](Solutions/0075.Sort_Colors.py) Sort Colors 三分的问题     <br>
  解法：分成两个部分 vs 分成三个部分 1)2次partition，先分0和1-2，再分1-2  2)只能1次循环    下次尝试1这个方法   <br>

5.其他排序 Rainbow sort   低频下次再写 (待做)  烙饼排序 先解决最下面的变成最大   睡眠排序  （不考） 面条排序  （不考） 猴子排序：洗牌算法  （不考） <br>

### [同向双指针]()
- [0088. Merge Sorted Array.java](Solutions/0088.Merge_Sorted_Array.java) (E) <br>
- [0283.Move_Zeroes.py](Solutions/0283.Move_Zeroes.py) (E) <br>
- [0026.Remove_Duplicates_from_Sorted_Array.py](Solutions/0026.Remove_Duplicates_from_Sorted_Array.py) (!!E) <br>
- [0083.Remove_Duplicates_from_Sorted_List.py](Solutions/0083.Remove_Duplicates_from_Sorted_List.py) (!!E) <br>
- [0082.Remove_Duplicates_from_Sorted_List_II.py](Solutions/0082.Remove_Duplicates_from_Sorted_List_II.py) (M) <br>
- [0203.Remove_Linked_List_Elements.py](Solutions/0203.Remove_Linked_List_Elements.py) (!!E) <br>

TODO
0042. Trapping Rain Water (!!H)
https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
http://www.lintcode.com/problem/valid-palindrome/
