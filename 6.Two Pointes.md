PPT上题目做完了
## [第六课：Two Pointes 两根指针]()
一般适合时间复杂度要求是O（n）的

### [反向双指针]()
- [0977.Squares_of_a_Sorted_Array.py](Solutions/0977.Squares_of_a_Sorted_Array.py) (E) <br>
- [0011.Container_With_Most_Water.py](Solutions/0011.Container_With_Most_Water.py)  (!!M)  <br>

### [同向双指针]()
- [0088. Merge Sorted Array.java](Solutions/0088. Merge Sorted Array.java) (E) <br>
- [0283.Move_Zeroes.py](Solutions/0283.Move_Zeroes.py) (E) <br>
- [0026.Remove_Duplicates_from_Sorted_Array.py](Solutions/0026.Remove_Duplicates_from_Sorted_Array.py) (!!E) <br>
- [0083.Remove_Duplicates_from_Sorted_List.py](Solutions/0083.Remove_Duplicates_from_Sorted_List.py) (!!E) <br>
- [0082.Remove_Duplicates_from_Sorted_List_II.py](Solutions/0082.Remove_Duplicates_from_Sorted_List_II.py) (M) <br>
- [0203.Remove_Linked_List_Elements.py](Solutions/0203.Remove_Linked_List_Elements.py) (!!E) <br>

TODO
0042. Trapping Rain Water (!!H)
http://www.lintcode.com/problem/valid-palindrome/

### [quick sort + merge sort]()
- [0912.Sort an Array](Solutions/0912.Sort_an_Array.java)  <br>
  quick sort // merge sort
- [ 0215.Kth_Largest_Element_in_an_Array.java](Solutions/ 0215.Kth_Largest_Element_in_an_Array.java)  <br>
  Quick Select 利用快速排序  
  partition 也是快速排序中的一个步骤

### [partition]()
- [0031.Partition Array](Solutions/0031.Partition_Array.java) <br>
  Partition Array （lintcode） 注意：4个地方的判断语序写成一样的 
- [0373.Partition_Array_by_Odd_and_Even.py](Solutions/0373.Partition_Array_by_Odd_and_Even.py) (LintCode)<br>
- [0144.Interleaving_Positive_and_Negative_Numbers.py](Solutions/0144.Interleaving_Positive_and_Negative_Numbers.py) (LintCode)<br>
- [0049.Sort_Letters_by_Case.py](Solutions/0049.Sort_Letters_by_Case.py) (LintCode)<br>
- [0075.Sort Colors](Solutions/0075.Sort_Colors.java) Sort Colors 三分的问题     <br>
  解法：分成两个部分 vs 分成三个部分 1)2次partition，先分0和1-2，再分1-2  2)只能1次循环    下次尝试1这个方法   <br>

5.其他排序 
Rainbow sort   低频下次再写 (待做)
烙饼排序 先解决最下面的变成最大  
睡眠排序  （不考）
面条排序  （不考）
猴子排序：洗牌算法  （不考）

### [Two Sum]()
模板必记：可以循环其中一个变量，然后研究另外一个变量如何变化
方法：哈希表(HashMap) vs 两根指针(Two Pointers)
如果没有说数组有没有重复，一定要记得去重

- [0001.Two Sum](Solutions/0001.Two_Sum.java)(!!E) <br>  
  方法：a.hashmap 存<nums[i], i>   b.先排序[需要保存index] 低空间复杂度 two pointers  <br>
- [0167.Two Sum II Input Array Is Sorted](Solutions/0167.Two_Sum_II_Input_Array_Is_Sorted.java) (E)（array-排好序的-使用 Two Pointers 会更快）<br> 
- [0170.Two_Sum_III_Data_structure_design](Solutions/0170.Two_Sum_III_Data_structure_design.java) (E) (array-求存不存在-可能有重复) <br> 
  Data structure design 只能使用HashMap，数组大小固定不能添加新元素，所以不能用2根指针
- [0653.Two_Sum_IV-Input_is_a_BST.java](Solutions/0653.Two_Sum_IV-Input_is_a_BST.java) (E)  Two Sum IV  (Input is a BST) <br> 
- [1214.Two_Sum_BSTs.py](Solutions/1214.Two_Sum_BSTs.py) (M)  <br> 
- [1099.Two_Sum_Less_Than_K.py](Solutions/1099.Two_Sum_Less_Than_K.py) (E) <br> 
- [0609.Two_Sum-Less_than_or_equal_to_target.py](Solutions/0609.Two_Sum-Less_than_or_equal_to_target.py) (!!E Lintcode) <br> 
- [0043.Two_Sum-Greater_than_target.py](Solutions/0043.Two_Sum-Greater_than_target.py) (!!E Lintcode) <br> 
- [0533.Two Sum - Closest to target](Solutions/0533.Two_Sum - Closest_to_target.java) Two Sum Closest (lintcode)  <br>  
- [0587.Two_Sum-Unique_pairs.py](Solutions/0587.Two_Sum-Unique_pairs.py)  (!!M) Unique pairs 是否可以先去重？不能  <br> 
- [0012.Two_Sum-Difference_equals_to_target.py](Solutions/0012.Two_Sum-Difference_equals_to_target.py) 只能同向双指针做 (lintcode)  <br>  

### [3 Sum & 4 Sum]()
- [0015.3Sum](Solutions/0015.3Sum.java)  (!!M) 3Sum  统计所有的和为0的三元组（Triples） <br>  
- [0016.3Sum Closest](Solutions/0016.3Sum_Closest.java) (M) 3Sum Closest <br>   
- [0259.3Sum_Smaller.py](Solutions/0259.3Sum_Smaller.py) (M)  <br>   
- [0018.4Sum.py](Solutions/0018.4Sum.py) (M)  <br>   
- [0454.4Sum_II.py](Solutions/0454.4Sum_II.py) (M)  <br>   
