## [第四课：Depth_First_Search 深度优先搜索](/Data-Structure.py) 
总结： <br>
BFS:while + queue  <br>
DFS:1.递归 、2.stack  一般用DFS   <br>

使用场景：  <br>
碰到让你找所有方案的题，一定是DFS    <br>
90%DFS的题，要么是排列，要么是组合   <br>
DFS更节约空间   <br>
DFS算法有时候=回溯算法   <br>

递归三要素：   <br>
• 递归的定义   <br>
• 递归的拆解   <br>
• 递归的出口   <br>
一般来说，如果面试官不特别要求的话，DFS都可以使用递归(Recursion)的方式来实现。 递归三要素是实现递归的重要步骤.  <br>

回溯法式一种通用算法，在部分DFS算法中用到了回溯的思想。   <br>
Backtracking is a more general purpose algorithm.   <br>
Depth-First search is a specific form of backtracking related to searching tree structures.   <br>

### [dfs graph 系列](/Data-Structure.py)
这类问题最好用BFS做，但是DFS也可以做    <br>
- [0261.Graph_Valid_Tree.java](Solutions/0261.Graph_Valid_Tree.py) (!!M) <br>
- [0133.Clone_Graph.java](Solutions/0133.Clone_Graph.java) (!!!M) <br>
- [0785.Is_Graph_Bipartite.java](Solutions/0785.Is_Graph_Bipartite.java) (!!!M) <br>
- [0886.Possible_Bipartition.java](Solutions/0886.Possible_Bipartition.java) (!!M Google)  <br>
TODO: 1042.Flower Planting With No Adjacent (!!M)
- [0690.Employee_Importance.java](Solutions/0690.Employee_Importance.java) (!!E Google)  <br>

### [dfs 系列之 island问题](/Data-Structure.py)
- [0200.Number_of_Islands.java ](Solutions/0200.Number_of_Islands.java) (!!M) <br>
- [0695.Max_Area_of_Island.java](Solutions/0695.Max_Area_of_Island.java) (M) <br>
- [1254.Number_of_Closed_Islands.Java](Solutions/1254.Number_of_Closed_Islands.Java) (!!M) <br>
- [1020.Number_of_Enclaves.java](Solutions/1020.Number_of_Enclaves.java) (M) <br>
- [0694.Number of Distinct Islands](Solutions/0694.Number of Distinct Islands) (!!M) <br>

## [dfs+Backtrack - subsets and combinations](/Data-Structure.py) 
diff: subset vs combination vs Permutation 
subset:       无重复元素  一个数只能选一次  2的n次方 
combination:  有重复元素  一个数可以选很多次（搜索时从index）  (1,2,3) (3,2,1) 无区别
permutation:  顺序“相关”   (1,2,3) (3,2,1) 有区别

### [组合搜索问题 Combination](/Data-Structure.py) 
n个元素的数组，组合个数为2^n次方
问题模型:求出所有满足条件的“组合”。 <br>
判断条件:组合中的元素是顺序无关的。 <br>
时间复杂度:与 2^n 相关。<br>
- [0078.Subsets](Solutions/0078.Subsets.java) (M) <br>
- [0090.Subsets_II](Solutions/0090.Subsets_II) (M) <br>
- [0039.Combination Sum](Solutions/0039.Combination_Sum.java) (M) <br>
- [0040.Combination_Sum_II](Solutions/0040.Combination_Sum_II.java) (M) <br>
- [0216.Combination_Sum_III.java](Solutions/0216.Combination_Sum_III.java) (M) <br>   TODO：Backtrack 和DFS区别是什么？老丁答案有两个版本
- [00090.k_Sum_II.java](0090.k_Sum_II.java) (M Lintcode) 同216 <br> 
- 0377. Combination Sum IV (M)                                     用DFS会超时，改成DP时再做       TODO
- [0518.Coin_Change_2.java](0518.Coin_Change_2.java) (!!!!!!!!!!M) DFS超时 用DP  <br> TODO
- [0131.Palindrome Partitioning](Solutions/0131.Palindrome_Partitioning.java) Palindrome Partitioning 解题思路：字母和字母之间的位置当成切和不切，从s的startIndex进行切分<br>

时间复杂度通用公式：
搜索的时间复杂度：O(答案总数 * 构造每个答案的时间)   不能明显知道答案个数，就用s，所以为s*n      
通用的DFS时间复杂度计算公式 O(答案个数 * 构造每个答案的时间)
举例Subsets问题，求所有的子集，子集个数一共2^n，每个集合的平均长度是O(n)的，所以时间复杂度为O(n*2^n),同理Permutations问题的时间度咋读为O（n*n!）

### [排列搜索问题 Permutation](/Data-Structure.py) 
全排列=n！
问题模型:求出所有满足条件的“排列”。 
判断条件:组合中的元素是顺序“相关”的。 
时间复杂度:与 n! 相关。
- [0046.Permutations.java](Solutions/0046.Permutations.java) (M) <br>
- [0047.Permutations_II](Solutions/0047.Permutations_II.java) (M) <br>

## [dfs+Backtrack - on graphs](/Data-Structure.py)  
- [0113.Path_Sum_II.java](0113.Path_Sum_II.java) (!!M) 注意与Combination区别那是一个数的选与不选<br> 
- [0017.Letter Combinations_of_a_Phone_Number.java](0017.Letter Combinations_of_a_Phone_Number.java) (!!M) <br> 
- [0079.Word_Search.java](0079.Word_Search.java) (!!M) <br> 

### [dfs-图中的搜索 Search in a Graph](/Data-Structure.py)  
N皇后问题（一）·N-Queens  TODO
N皇后问题（二）·N-Queens  TODO

- [0127.Word Ladder](Solutions/0127.Word_Ladder.java) (M) <br>
Word Ladder II：TODO 太难了
求出所有的最短路径，碰到让你找所有方案的题，一定是DFS，所以一定用到了DFS；如果单纯用DFS，相当于要求出所有的路径，然后比较最短的路径，时间复杂度高。
所以要用BFS+DFS，用BFS每次获取距离终点最近的点，怎么得到每个点到终点的距离？从终点开始做DFS

求一个值在不在hash表中的算法复杂度？O(1)? 更准确的说法O(L)  L为这个值的长度

### [必背程序]()
0144.Binary_Tree_Preorder_Traversal.java  <br>
0094.Binary_Tree_Inorder_Traversal.java   <br>
0145.Binary_Tree_Postorder_Traversal.java   <br>
0173.Binary_Search_Tree_Iterator.java   <br>
0078.Subsets.java     <br>
0039.Combination_Sum.java   <br>
0046.Permutations.java   <br>
 
### [Stack-Non Recursion]()

总结：BFS和DFS区别，BFS擅长求点，DFS擅长求路径

DFS不回溯的题目：Number of Islands，因为就是要找点，不是要找路径
