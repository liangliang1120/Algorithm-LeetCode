## [第四课：Depth_First_Search 深度优先搜索](/Data-Structure.py) 
模板1：DFS的模板
模板2：DFS + 回溯的模板

BFS:while + queue  <br>
DFS:1.递归 2.stack  一般用DFS   <br>

使用场景：  <br>
碰到让你找所有方案的题，一定是DFS    <br>
90%DFS的题，要么是排列，要么是组合   <br>
DFS更节约空间   <br>
DFS算法有时候=回溯算法   <br>

递归三要素：   <br>
• 递归的定义   <br>
• 递归的拆解   <br>
• 递归的出口   <br>
一般来说，如果面试官不特别要求的话，DFS都可以使用递归(Recursion)的方式来实现。 递归三要素是实现递归的重要步骤.  <br>

回溯法式一种通用算法，在部分DFS算法中用到了回溯的思想。   <br>
Backtracking is a more general purpose algorithm.   <br>
Depth-First search is a specific form of backtracking related to searching tree structures.   <br>

### [dfs graph 系列](/Data-Structure.py)
这类问题最好用BFS做，但是DFS也可以做    <br>
- [0261.Graph_Valid_Tree.java](Solutions/0261.Graph_Valid_Tree.py) (!!M) <br>
- [0133.Clone_Graph.java](Solutions/0133.Clone_Graph.py) (!!!M) <br>
- BFS是 1.先获取所有节点 2.复制节点到mapping中 3.再复制边  // DFS是边新建节点边复制边 
- [0785.Is_Graph_Bipartite.java](Solutions/0785.Is_Graph_Bipartite.py) (!!!M) <br>
- [0886.Possible_Bipartition.java](Solutions/0886.Possible_Bipartition.py) (!!M Google)  <br>
- [1042.Flower Planting With No Adjacent.py](Solutions/1042.Flower_Planting_With_No_Adjacent.py) (!!M)  <br>
- [0690.Employee_Importance.java](Solutions/0690.Employee_Importance.py) (!!E Google)  <br>
- 多种解法：1. 递归(最简单-直接在原来方法上递归) 2.dfs  3.递归（用新helper函数）

### [dfs 系列之 island问题](/Data-Structure.py)
- [0200.Number_of_Islands.java ](Solutions/0200.Number_of_Islands.py) (!!M) <br>
- [0695.Max_Area_of_Island.java](Solutions/0695.Max_Area_of_Island.py) (M) <br>
- DFS(注意递归的定义):返回 以i,j为起点的island的面积  //  BFS 
- [1254.Number_of_Closed_Islands.Java](Solutions/1254.Number_of_Closed_Islands.py) (!!M) <br>
- [1020.Number_of_Enclaves.java](Solutions/1020.Number_of_Enclaves.py) (M) <br>
- [0694.Number of Distinct Islands](Solutions/0694.Number_of_Distinct_Islands.py) (!!M) <br>

## [dfs+Backtrack - subsets and combinations and permutations](/Data-Structure.py)
一般回溯的问题有两种：
1. 打印/输出所有路径的问题一定是回溯。如果要求输出所有最短路径则需要DFS+BFS
2. 打印或输出所有组合/排列的问题：combination/permutation （eg: subsets/permutations 问题）

diff: subset vs combination vs Permutation 
subset:       无重复元素  一个数只能选一次  2的n次方 
combination:  可以有重复元素  一个数可以选很多次（搜索时从index）  (1,2,3) (3,2,1) 无区别
permutation:  顺序“相关”   (1,2,3) (3,2,1) 有区别

### [组合搜索问题 Combination](/Data-Structure.py) 
n个元素的数组，组合个数为2^n次方
问题模型:求出所有满足条件的“组合”。 <br>
判断条件:组合中的元素是顺序无关的。 <br>
时间复杂度:与 2^n 相关。<br>
- [0078.Subsets](Solutions/0078.Subsets.py) (M) <br>
- [0090.Subsets_II](Solutions/0090.Subsets_II.py) (M) <br>
- [0039.Combination Sum](Solutions/0039.Combination_Sum.py) (M) <br>
- [0040.Combination_Sum_II](Solutions/0040.Combination_Sum_II.py) (M) <br>
- [0216.Combination_Sum_III](Solutions/0216.Combination_Sum_III.py) (M) <br>
- 0377. Combination Sum IV (M)  用DFS会超时，改成DP时再做       TODO
- [0090.k_Sum_II.java](0090.k_Sum_II.py) (M Lintcode) 同216 <br> 
- [0518.Coin_Change_2.java](0518.Coin_Change_2.java) (!!!!!!!!!!M) DFS超时 用DP  TODO <br> 
- [0131.Palindrome Partitioning](Solutions/0131.Palindrome_Partitioning.py) Palindrome Partitioning 解题思路：字母和字母之间的位置当成切和不切，从s的startIndex进行切分<br>

时间复杂度通用公式：
搜索的时间复杂度：O(答案总数 * 构造每个答案的时间)   不能明显知道答案个数，就用s，所以为s*n      
通用的DFS时间复杂度计算公式 O(答案个数 * 构造每个答案的时间)
举例Subsets问题，求所有的子集，子集个数一共2^n，每个集合的平均长度是O(n)的，所以时间复杂度为O(n*2^n),同理Permutations问题的时间度咋读为O（n*n!）

### [排列搜索问题 Permutation](/Data-Structure.py) 
全排列=n！
问题模型:求出所有满足条件的“排列”。 
判断条件:组合中的元素是顺序“相关”的。 
时间复杂度:与 n! 相关。
- [0046.Permutations.java](Solutions/0046.Permutations.py) (M) <br>
- [0047.Permutations_II](Solutions/0047.Permutations_II.py) (M) <br>

## [dfs+Backtrack - on graphs](/Data-Structure.py)  
- [0113.Path_Sum_II.java](0113.Path_Sum_II.java) (!!M) 注意与Combination区别那是一个数的选与不选<br> 
- [0017.Letter Combinations_of_a_Phone_Number.java](0017.Letter Combinations_of_a_Phone_Number.java) (!!M) <br> 
- [0079.Word_Search.java](0079.Word_Search.java) (!!M) <br> 

### [dfs-图中的搜索 Search in a Graph](/Data-Structure.py)  
N皇后问题（一）·N-Queens  TODO
N皇后问题（二）·N-Queens  TODO

- [0127.Word Ladder](Solutions/0127.Word_Ladder.java) (M) <br>
Word Ladder II：TODO 太难了
求出所有的最短路径，碰到让你找所有方案的题，一定是DFS，所以一定用到了DFS；如果单纯用DFS，相当于要求出所有的路径，然后比较最短的路径，时间复杂度高。
所以要用BFS+DFS，用BFS每次获取距离终点最近的点，怎么得到每个点到终点的距离？从终点开始做DFS

求一个值在不在hash表中的算法复杂度？O(1)? 更准确的说法O(L)  L为这个值的长度

### [必背程序]()
0144.Binary_Tree_Preorder_Traversal.java  <br>
0094.Binary_Tree_Inorder_Traversal.java   <br>
0145.Binary_Tree_Postorder_Traversal.java   <br>
0173.Binary_Search_Tree_Iterator.java   <br>
0078.Subsets.java     <br>
0039.Combination_Sum.java   <br>
0046.Permutations.java   <br>
 
### [Stack-Non Recursion]()

总结：BFS和DFS区别，BFS擅长求点，DFS擅长求路径

DFS不回溯的题目：Number of Islands，因为就是要找点，不是要找路径

DFS的题比较难
0785 DFS不会写
0377 DP再做  0518
