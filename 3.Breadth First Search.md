## [第三课：Breadth First Search 宽度优先搜索](/Data-Structure.py) 

宽度优先搜索：能够用BFS解决的问题都不要用DFS！！！
BFS写的目的：不用递归，用循环实现！！！

使用场景：<br>
求最短的路径就可以用BFS <br>
图的遍历 <br>
最短路径 <br>

数据结构：使用队列作为主要的数据结构 Queue（先进先出） <br>

模板：<br>
分层遍历三层循环 <br>
1.queue！= null <br>
2.size = queue.size 当前这一层的每个节点 <br>
3.for循环出当前层的每个节点的下一个单词<br>

非分层遍历二层循环  <br>
1.queue！= null  <br>
2.for循环出当前节点的下一个单词  <br>

### [a.二叉树上的宽搜 BFS in Binary Tree](/Data-Structure.py) 
模板 <br>
1.把源节点放入q中 <br>
2.while循环：把源节点一个个弹出q，与此同时把刚刚弹出来的节点的邻居（们）加入q
能够用BFS解决的问题，一定不要用DFS去做 <br>

二叉树上的宽度优先搜索 BFS in Binary Tree：
- [0102.Binary Tree Level Order Traversal](Solutions/0102.Binary_Tree_Level_Order_Traversal.py) (!!M, youtubed)<br>
- [0107.Binary Tree Level Order Traversal II](Solutions/0107.Binary_Tree_Level_Order_Traversal_II.java)(E) <br> 
  same as 102, 在res.append(level)的时候间隔性选择res.append(level) or res.append(level[::-1])<br> 
- [0103.Binary_Tree_Zigzag_Level_Order_Traversal.java](Solutions/0103.Binary_Tree_Zigzag_Level_Order_Traversal.java) (M) <br> 
- [0242.Convert Binary Tree to Linked Lists by Depth](Solutions/0242.Convert_Binary_Tree_to_Linked_Lists_by_Depth.java)  (LintCode) <br> 
- [0111.Minimum_Depth_of_Binary_Tree.java](Solutions/0111.Minimum_Depth_of_Binary_Tree.py) (!!!E)  <br>
- [0199.Binary_Tree_Right_Side_View](Solutions/0199.Binary_Tree_Right_Side_View.java)  (M) <br>
  same as 102, just need record most right node 
- [0513.Find_Bottom_Left_Tree_Value.java](Solutions/0513.Find_Bottom_Left_Tree_Value.java) (M) <br>
首先想到的是要求bottom的node, 所以用bfs渠道最下面一层，然后要求left_most, 所以我们可以在bfs append下一层的时候先append right, then append left, 这样最后一个node就是botoom left node了 <br>
- [0515.Find_Largest_Value_in_Each_Tree_Row.java](Solutions/0515.Find_Largest_Value_in_Each_Tree_Row.java) (M) <br>
- [1161.Maximum_Level_Sum_of_a_Binary_Tree.java](Solutions/1161.Maximum_Level_Sum_of_a_Binary_Tree.java) (M) <br>

### [序列化知识点]() 
序列化：将“内存”中结构化的数据变成“字符串”的过程 序列化:object to string 反序列化:string to object<br>
什么时候需要序列化?<br>
1. 将内存中的数据持久化存储时<br>
内存中重要的数据不能只是呆在内存里，这样断电就没有了，所需需要用一种方式写入硬盘，在需要的 时候，能否再从硬盘中读出来在内存中重新创建<br>
2. 网络传输时 机器与机器之间交换数据的时候，不可能互相去读对方的内存。只能讲数据变成字符流数据(字符串)后<br>
通过网络传输过去。接受的一方再将字符串解析后到内存中。 常用的一些序列化手段:<br>
• XML<br>
• Json<br>
• Thrift (by Facebook)<br>
• ProtoBuf (by Google)<br>

序列化算法：一些序列化的例子:<br>
• 比如一个数组，里面都是整数，我们可以简单的序列化为”[1,2,3]”<br>
• 一个整数链表，我们可以序列化为，”1->2->3”<br>
• 一个哈希表(HashMap)，我们可以序列化为，”{\”key\”: \”value\”}”<br>
序列化算法设计时需要考虑的因素:<br>
• 压缩率。对于网络传输和磁盘存储而言，当然希望更节省。<br>
• 如 Thrift, ProtoBuf 都是为了更快的传输数据和节省存储空间而设计的。<br>
• 可读性。我们希望开发人员，能够通过序列化后的数据直接看懂原始数据是什么。<br>
• 如 Json，LintCode 的输入数据 <br>

- [0449.Serialize and Deserialize BST](Solutions/0449.Serialize_and_Deserialize_BST.java) (M) <br>
Same as 297. Solution says since BST, the answer could be as compact as possible. Don't know how?
 
### [b.图上的宽搜 BFS in Graph](/Data-Structure.py) 
区别：图上的宽搜 BFS in Graph，和树上有什么区别？图中存在环，存在环意味着，同一个节点可能重复进入队列，所以HashMap很好用 <br>
图的几种表示方式：
数组： [head][tail] 长度是边数
链表： Map<Integer, Set<Integer>> graph  <br>

- [0261.Graph Valid Tree](Solutions/0261.Graph_Valid_Tree.java) (!!!M) 
  判断图是不是树？<br>
  1.边树刚好等于n-1，点数和边数差1 <br>
  2.n-1条边一定要把整个图连起来，判断连通性，就是通过一个点把其他的点都能找到 <br>
  实现方法：1.BFS 2.DFS非递归  3.DFS递归
- [0133.Clone Graph](Solutions/0133.Clone_Graph.java) (!!!M)  <br>
  方法一：BFS step1:先BFS找到所有的node  step2:复制新的node放入mapping  step3:复制边 <br>
  方法二：DFS 用一个mapping 保存node-->node_copy. 然后一边dfs一边新建copied nodes <br>
- [0618.Search Graph Nodes](Solutions/0618.Search_Graph_Nodes.java) (LintCode)  图的遍历(由点及面) <br>    //
如何找所有最近的value=target的点? 加上层序遍历

#### [拓扑排序 Topological Sorting](/Data-Structure.py) 
有向图的问题，可以检测有向图是否有环！必考，其实也非常模板化，一定要记住。
Three steps: 
1. 从数字关系求出每个节点的inDegrees（就是找节点与相邻节点的依赖关系） (inDegrees = collections.defaultdict(int))，key是node, val是这个node的indegree值; 
2. 和每个节点的neighbors （neighbors = collections.defaultdict(list)), key是node, val是装有这个node的neighbor的list; 
3. 然后 BFS，背诵模板就可以了。
 
Three steps: 
  1. construct a dictoinary of adjacency list for the graph   hashmap存储临接关系
  2. get in_degree information for all nodes
  3. topological sort - bfs
  step I: initialze q by putting all in_degree = 0 into q
  step II: keep adding in_degree = 0 node into q and pop out while updating res

- [0127.Topological Sorting.java ](Solutions/0127.Topological_Sorting.java) (!!LintCode)  <br>
- [0207.Course_Schedule.java](Solutions/0207.Course_Schedule.java) (!!M)  <br>
  套用模板分三步：1. construct a dictoinary of adjacency list for the graph; 2. get in_degree information for all nodes; 3. topological sort -   bfs: step I: initialze q by putting all in_degree = 0 into q; step II: keep adding in_degree = 0 node into q and pop out while updating res
- [0210.Course_Schedule_II.java](Solutions/0210.Course_Schedule_II.java) (!!M)  <br> 
- [1136.Parallel_Courses.java](Solutions/1136.Parallel_Courses.java) (!!H)  <br> 
http://www.lintcode.com/problem/sequence-reconstruction/
裸拓扑排序:判断是否只存在一个拓扑排序的序列 只需要保证队列中一直最多只有1个元素即可

### [c.矩阵中的宽度优先搜索BFS in Matrix](/Data-Structure.py) 
图 Graph
N个点，M条边
M最大是 O(N^2) 的级别 图上BFS时间复杂度 = O(M) 所以最坏情况可能是 O(N^2)

矩阵 Matrix
N行M列
N*M个点，N*M*2 条边(每个点上下左右4条边，每条边被2个点共享)。 矩阵中BFS时间复杂度 = O(N * M)

图的遍历(由点及面)(层级遍历)   Number of Islands 经典矩阵宽度优先搜索 
- [0200.Number_of_Islands.java](Solutions/0200.Number_of_Islands.java) (!!LintCode) <br>
- [0598.Zombie in Matrix](Solutions/0598.Zombie_in_Matrix.java) (!!LintCode) <br>
- [0994.Rotting_Oranges.java](Solutions/0994.Rotting_Oranges.java) (M) <br>
- [0286.Walls_and_Gates.java](Solutions/0286.Walls_and_Gates.java) (M) <br>
 求最小距离问题，必须用bfs. Step 1: append all the gates into the queue; Step 2: change all the EMPTY rooms to a value that equals the layer  number, 必须层序遍历才可以保证每次都能变成最小距离<br>
- [1162.As_Far_from_Land_as_Possible.java](Solutions/1162.As_Far_from_Land_as_Possible.java) (!!M) <br>
- [0542.01_Matrix.java](Solutions/0542.01_Matrix.java) (M) <br>

### [d.自己构建图类型](/Data-Structure.py) 
简单图最短路径 
- [0127.Word_Ladder.java](Solutions/0127.Word_Ladder.java) (!!M) <br>
 node是某个单词，_get_next(curr_node)是这一题的难点，构造一个dictionary, key is all possible combination of the word, value is the word, 这样就可以快速查询了。Time complexity: O(NL^2), where N is the number of words in word_set, and L is avg length of words
- [0433.Minimum_Genetic_Mutation.java](Solutions/0433.Minimum_Genetic_Mutation.java) (!!M) <br>
- [0752.Open_the_Lock.java](Solutions/0752.Open_the_Lock.java) (!!M Google) <br> 
- [0611.Knight Shortest Path](Solutions/0611.Knight_Shortest_Path.java) (!!LintCode) <br>
- [0573.Build Post Office II](Solutions/0573.Build_Post_Office_II.java) (!!LintCode) <br>

TODO:
图的遍历(由点及面)
• 无向图联通块
• http://www.lintcode.com/problem/connected-component-in-undirected-graph/ 
• 覆盖黑点的最小矩阵(BFS无法AC但是可以作为BFS的练习题)
• http://www.lintcode.com/problem/smallest-rectangle-enclosing-black-pixels/
