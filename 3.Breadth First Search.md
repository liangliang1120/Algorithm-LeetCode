## [第三课：Breadth First Search 宽度优先搜索](/Data-Structure.py) 

使用场景：求最短的路径就可以用BFS
图的遍历
最短路径

数据结构：使用队列作为主要的数据结构 Queue（先进先出）

模板：
分层遍历三层循环 
1.queue！= null 
2.size = queue.size 当前这一层的每个节点 
3.for循环出当前层的每个节点的下一个单词

非分层遍历二层循环
1.queue！= null 
2.for循环出当前节点的下一个单词

### [a.二叉树上的宽搜 BFS in Binary Tree模板](/Data-Structure.py) 
1.把源节点放入q中
2.while循环：把源节点一个个弹出q，与此同时把刚刚弹出来的节点的邻居（们）加入q
能够用BFS解决的问题，一定不要用DFS去做

二叉树上的宽度优先搜索 BFS in Binary Tree：
- [0102.Binary Tree Level Order Traversal](Solutions/0102.Binary_Tree_Level_Order_Traversal.java)<br>
- [0107.Binary Tree Level Order Traversal II](Solutions/0107.Binary_Tree_Level_Order_Traversal_II.java)<br> 
- [0103.Binary_Tree_Zigzag_Level_Order_Traversal.java](Solutions/0103.Binary_Tree_Zigzag_Level_Order_Traversal.java)<br> 
- [0242.Convert Binary Tree to Linked Lists by Depth](Solutions/0242.Convert_Binary_Tree_to_Linked_Lists_by_Depth.java)  (LintCode) <br> 
- [0111.Minimum_Depth_of_Binary_Tree.java](Solutions/0111.Minimum_Depth_of_Binary_Tree.java)   <br>
- [0199.Binary_Tree_Right_Side_View](Solutions/0199.Binary_Tree_Right_Side_View.java)  same as 102, just need record most right node <br>
- [0513._Find_Bottom_Left_Tree_Value.java](Solutions/0513._Find_Bottom_Left_Tree_Value.java)<br>
首先想到的是要求bottom的node, 所以用bfs渠道最下面一层，然后要求left_most, 所以我们可以在bfs append下一层的时候先append right, then append left, 这样最后一个node就是botoom left node了
- [ 0515.Find_Largest_Value_in_Each_Tree_Row.java](Solutions/ 0515.Find_Largest_Value_in_Each_Tree_Row.java)<br>
- [ 1161.Maximum_Level Sum_of_a_Binary_Tree.java](Solutions/1161.Maximum_Level Sum_of_a_Binary_Tree.java)<br>

### [序列化知识点]() 
序列化：将“内存”中结构化的数据变成“字符串”的过程 序列化:object to string 反序列化:string to object
什么时候需要序列化?
1. 将内存中的数据持久化存储时
内存中重要的数据不能只是呆在内存里，这样断电就没有了，所需需要用一种方式写入硬盘，在需要的 时候，能否再从硬盘中读出来在内存中重新创建
2. 网络传输时 机器与机器之间交换数据的时候，不可能互相去读对方的内存。只能讲数据变成字符流数据(字符串)后
通过网络传输过去。接受的一方再将字符串解析后到内存中。 常用的一些序列化手段:
• XML
• Json
• Thrift (by Facebook)
• ProtoBuf (by Google)

序列化算法：一些序列化的例子:
• 比如一个数组，里面都是整数，我们可以简单的序列化为”[1,2,3]”
• 一个整数链表，我们可以序列化为，”1->2->3”
• 一个哈希表(HashMap)，我们可以序列化为，”{\”key\”: \”value\”}”
序列化算法设计时需要考虑的因素:
• 压缩率。对于网络传输和磁盘存储而言，当然希望更节省。
• 如 Thrift, ProtoBuf 都是为了更快的传输数据和节省存储空间而设计的。
• 可读性。我们希望开发人员，能够通过序列化后的数据直接看懂原始数据是什么。
• 如 Json，LintCode 的输入数据

- [0449.Serialize and Deserialize BST](Solutions/0449.Serialize_and_Deserialize_BST)<br>
Same as 297. Solution says since BST, the answer could be as compact as possible. Don't know how?
 
### [b.图上的宽搜 BFS in Graph](/Data-Structure.py) 

判断图是不是树？
1.边树刚好等于n-1，点数和边数差1
2.n-1条边一定要把整个图连起来，判断连通性，就是通过一个点把其他的点都能找到
区别：图上的宽搜 BFS in Graph，和树上有什么区别？图中存在环，存在环意味着，同一个节点可能重复进入队列，所以HashMap很好用

- [0261.Graph Valid Tree](Solutions/0261.Graph_Valid_Tree.java) (!!!M) <br>
- [0133.Clone Graph](Solutions/0133.Clone_Graph.java) (!!!M) <br>
- [0618.Search Graph Nodes](Solutions/0618.Search_Graph_Nodes.java) (LintCode)  图的遍历(由点及面) <br>    //
如何找所有最近的value=target的点? 加上层序遍历

#### [拓扑排序 Topological Sorting](/Data-Structure.py) 
有向图的问题，可以检测有向图是否有环！必考，其实也非常模板化，一定要记住。
Three steps: 
1. 从数字关系求出每个节点的inDegrees（就是找节点与相邻节点的依赖关系） (inDegrees = collections.defaultdict(int))，key是node, val是这个node的indegree值; 
2. 和每个节点的neighbors （neighbors = collections.defaultdict(list)), key是node, val是装有这个node的neighbor的list; 
3. 然后 BFS，背诵模板就可以了。

- [0127.Topological Sorting.java ](Solutions/0127.Topological_Sorting.java) (!!LintCode)  <br>
- [0207.Course_Schedule.java](Solutions/0207.Course_Schedule.java) ()  <br>
- [0210.Course_Schedule_II.java](Solutions/0210.Course_Schedule_II.java) ()  <br> 
- [1136.Parallel_Courses.java](Solutions/1136.Parallel_Courses.java) ()  <br> 
http://www.lintcode.com/problem/sequence-reconstruction/
- [1136.Parallel_Courses.java](Solutions/1136.Parallel_Courses.java) ()  <br> 
裸拓扑排序:判断是否只存在一个拓扑排序的序列 只需要保证队列中一直最多只有1个元素即可

### [c.矩阵中的宽度优先搜索BFS in Matrix](/Data-Structure.py) 
图 Graph
N个点，M条边
M最大是 O(N^2) 的级别 图上BFS时间复杂度 = O(M) 所以最坏情况可能是 O(N^2)

矩阵 Matrix
N行M列
N*M个点，N*M*2 条边(每个点上下左右4条边，每条边被2个点共享)。 矩阵中BFS时间复杂度 = O(N * M)

图的遍历(由点及面)(层级遍历)   Number of Islands 经典矩阵宽度优先搜索 
- [0200.Number_of_Islands.java](Solutions/0200.Number_of_Islands.java) (!!LintCode) <br>
- [0598.Zombie in Matrix](Solutions/0598.Zombie_in_Matrix.java) (!!LintCode) <br>
- [0994.Rotting_Oranges.java](Solutions/0994.Rotting_Oranges.java) (M) <br>
- [0286.Walls_and_Gates.java](Solutions/0286.Walls_and_Gates.java) (M) <br>
- [1162.As_Far_from_Land_as_Possible.java](1162.As_Far_from_Land_as_Possible.java) (M) <br>
- [0542.01_Matrix.java](0542.01_Matrix.java) (M) <br>

### [d.自己构建图类型](/Data-Structure.py) 
简单图最短路径 
- [0127.Word_Ladder.java](Solutions/0127.Word_Ladder.java) () <br>
- [0433.Minimum_Genetic_Mutation.java](Solutions/0433.Minimum_Genetic_Mutation.java) () <br>
- [0752.Open_the_Lock.java](Solutions/0752.Open_the_Lock.java) () <br>

简单图最短路径 
- [0611.Knight Shortest Path](Solutions/0611.Knight_Shortest_Path.java) (!!LintCode) <br>
- [0573.Build Post Office II](Solutions/0573.Build_Post_Office_II.java) (!!LintCode) <br>

TODO:
图的遍历(由点及面)
• 无向图联通块
• http://www.lintcode.com/problem/connected-component-in-undirected-graph/ 
• 覆盖黑点的最小矩阵(BFS无法AC但是可以作为BFS的练习题)
• http://www.lintcode.com/problem/smallest-rectangle-enclosing-black-pixels/


