## [第三课：Breadth First Search 宽度优先搜索](/Data-Structure.py) 
模板：BFS模板，拓扑排序模板

宽度优先搜索：能够用BFS解决的问题都不要用DFS！！！
BFS写的目的：不用递归，用循环实现！！！

使用场景：求最短的路径就可以用BFS // 图的遍历 // 最短路径 <br>
数据结构：使用队列作为主要的数据结构 Queue（先进先出） <br>

模板：<br>
分层遍历三层循环 <br>
1.queue！= null <br>
2.size = queue.size 当前这一层的每个节点 <br>
3.for循环出当前层的每个节点的下一个单词<br>

非分层遍历二层循环  <br>
1.queue！= null  <br>
2.for循环出当前节点的下一个单词  <br>

### [1.二叉树上的宽搜 BFS in Binary Tree](/Data-Structure.py) 
模板 <br>
1.把源节点放入q中. <br>
2.while循环：把源节点一个个弹出q，与此同时把刚刚弹出来的节点的邻居（们）加入q.
能够用BFS解决的问题，一定不要用DFS去做 <br>

二叉树上的宽度优先搜索 BFS in Binary Tree：
- [0102.Binary Tree Level Order Traversal](Solutions/0102.Binary_Tree_Level_Order_Traversal.py) (!!M, youtubed)<br>
  BFS的铁律就是用queue, 在while q: 循环里做两件事 1. 处理这一层。那就需要把这一层的node逐个pop出，然后append到res里，有时候需要用for循环for _ in range(len(q))来遍历这一层所有的node; 2. append下一层进q。BFS is O(N) since each node is processed exactly once.
- [0107.Binary Tree Level Order Traversal II](Solutions/0107.Binary_Tree_Level_Order_Traversal_II.py)(E) <br> 
  same as 102，只是题目要求从下至上输出，只需要return res[::-1]即可.
- [0103.Binary_Tree_Zigzag_Level_Order_Traversal](Solutions/0103.Binary_Tree_Zigzag_Level_Order_Traversal.py) (M) <br> 
  same as 102, 在res.append(level)的时候间隔性选择res.append(level) or res.append(level[::-1]).level[::-1]是从后往前输出array.
- [0242.Convert Binary Tree to Linked Lists by Depth](Solutions/0242.Convert_Binary_Tree_to_Linked_Lists_by_Depth.py)  (LintCode) <br> 
  将二叉树转换成层序遍历的linked list，然后输出.
- [0111.Minimum_Depth_of_Binary_Tree](Solutions/0111.Minimum_Depth_of_Binary_Tree.py) (!!!E)  <br>
  solution 1: recursion; soluiton 2: BFS; for _ in range(lens): if not node.left and not node.right: return depth.
- [0199.Binary_Tree_Right_Side_View](Solutions/0199.Binary_Tree_Right_Side_View.py)  (M) <br>
  same as 102, just need record most right node.
- [0513.Find_Bottom_Left_Tree_Value](Solutions/0513.Find_Bottom_Left_Tree_Value.py) (M) <br>
首先想到的是要求bottom的node, 所以用bfs渠道最下面一层，然后要求left_most, 所以我们可以在bfs append下一层的时候先append right, then append left, 这样最后一个node就是botoom left node了. <br>
- [0515.Find_Largest_Value_in_Each_Tree_Row](Solutions/0515.Find_Largest_Value_in_Each_Tree_Row.py) (M) <br>
  solution: 返回每一层的最大值的集合.
- [1161.Maximum_Level_Sum_of_a_Binary_Tree](Solutions/1161.Maximum_Level_Sum_of_a_Binary_Tree.py) (M) <br>
  solution: 返回最大的level，这个level上的最大sum.
- [0662.Maximum_Width_of_Binary_Tree.py](Solutions/0662.Maximum_Width_of_Binary_Tree.py) (M) <br>
涉及到处理level的信息，就用bfs, q里面存放(node, the postion of the node), 注意这里的pos到下一层的转换关系: q.append((node.left, 2* pos)).
- [0637.Average_of_Levels_in_Binary_Tree.py](Solutions/0637.Average_of_Levels_in_Binary_Tree.py) (M) <br>
level order traversal using a q.
- [0314.Binary_Tree_Vertical_Order_Traversal.py](Solutions/0314.Binary_Tree_Vertical_Order_Traversal.py) (M) <br>
record the position of each node as we dfs to traverse the tree. 记录在遍历过程中记录node位置的思想非常重要！
- [0987.Vertical_Order_Traversal_of_a_Binary_Tree.py](Solutions/0987.Vertical_Order_Traversal_of_a_Binary_Tree.py) (H) <br>
same as 314. in 314, left nodes output first, in 987, smaller value comes first. So the only difference is at sort



  
### [2.图上的宽搜 BFS in Graph](/Data-Structure.py) 
区别：图上的宽搜 BFS in Graph，和树上有什么区别？图中存在环，存在环意味着，同一个节点可能重复进入队列，所以HashMap很好用 <br>
图的几种表示方式：
数组： [head][tail] 长度是边数
链表： Map<Integer, Set<Integer>> graph  <br>

- [0261.Graph Valid Tree](Solutions/0261.Graph_Valid_Tree.py) (!!!M) 
  判断图是不是树？<br>
  1.边树刚好等于n-1，点数和边数差1 <br>
  2.n-1条边一定要把整个图连起来，判断连通性，就是通过一个点把其他的点都能找到 <br>
  实现方法：1.BFS 2.DFS非递归  3.DFS递归
- [0133.Clone Graph](Solutions/0133.Clone_Graph.py) (!!!M)  <br>
  方法一：BFS step1:先BFS找到所有的node  step2:复制新的node放入mapping  step3:复制边 <br>
  方法二：DFS 用一个mapping 保存node-->node_copy. 然后一边dfs一边新建copied nodes <br>
  TODO:问一下
- [0618.Search Graph Nodes](Solutions/0618.Search_Graph_Nodes.py) (LintCode)  图的遍历(由点及面) <br>    
  找所有最近的value=target的点?最近用BFS,直接遍历，第一个找到的就是最近。

### [c.矩阵中的宽度优先搜索BFS in Matrix](/Data-Structure.py) 
图 Graph
N个点，M条边
M最大是 O(N^2) 的级别 图上BFS时间复杂度 = O(M) 所以最坏情况可能是 O(N^2)

矩阵 Matrix
N行M列
N*M个点，N*M*2 条边(每个点上下左右4条边，每条边被2个点共享)。 矩阵中BFS时间复杂度 = O(N * M)

- [0200.Number_of_Islands](Solutions/0200.Number_of_Islands.py) (!!M) <br>
Linear scan the 2d grid map, if a node contains a '1', then it is a root node that triggers a Breadth First Search. Solution 2: dynamic connection problem, Union Find. Follow up: 如何找到这些岛屿有多少种不同的形状，union find就做不了了，只能dfs.
- [0598.Zombie in Matrix](Solutions/0598.Zombie_in_Matrix.py) (!!LintCode) <br>
- [0994.Rotting_Oranges](Solutions/0994.Rotting_Oranges.py) (M) <br>
Step 1. append the rotten ones to the first level, Step 2: 层序遍历的bfs to turn the adjacent fresh ones into rotten ones. 必须层序遍历才能保证最少时间make all fresh ones rotten 在class solution(): 后面定义全局变量 EMPTY = 0; FRESH = 1; MOVES = [(1, 0), (-1, 0), (0, 1), (0, -1)].
  
### [3.单/多源节点最短路径问题](/Data-Structure.py) 

**自己构建图类型**
- [0127.Word_Ladder.java](Solutions/0127.Word_Ladder.py) (!!M) <br>
node是某个单词，_get_next(curr_node)是这一题的难点，构造一个dictionary, key is all possible combination of the word, value is the word, 这样就可以快速查询了。Time complexity: O(NL^2), where N is the number of words in word_set, and L is avg length of words
- [0433.Minimum_Genetic_Mutation.java](Solutions/0433.Minimum_Genetic_Mutation.py) (!!M) <br>
same as 127. Word Ladder. 双端bfs大大提高速度
- [0752.Open_the_Lock.py](Solutions/0752.Open_the_Lock.py) (!!M Google) <br> 
题目蛮有意思的, 带层序遍历的bfs, 遇到currNode in deadends 就不再去访问其neighbor了, find neighbor 函数比较有意思，这里第一次学到了yield;  
- [0611.Knight Shortest Path](Solutions/0611.Knight_Shortest_Path.py) (!!LintCode)(M) <br>
Solution:棋盘中从start调到end，求最短路径。
- [0573.Build Post Office II](Solutions/0573.Build_Post_Office_II.py) (!!LintCode)(H) <br>
Solution:枚举邮局位置:for 邮局位置 => O(SPACE),计算所有点离邮局的距离=计算邮局离所有点的距离 => O(nm).总体时间复杂度 O(SPACEnm)，最坏情况 O(n^2*m^2)
- [1162.As_Far_from_Land_as_Possible](Solutions/1162.As_Far_from_Land_as_Possible.py) (!!M) <br>
Solution:从地找水，最晚找到的就是水距离最近的陆地的最大值.bfs: the maximum distance is steps needed to change all WATER to be LAND, so we append all land into the first layer of q, and do a level order bfs. the maxumum distance is then the answer we want. solution 2: DP same as 542. 01 matrix.
- [0542.01_Matrix](Solutions/0542.01_Matrix.py) (M) <br>
  方法是先把所有0放入q的第一层，然后一层层遍历，同时更新遇到的1为当前的层数，层数就是1离0的距离; solution 2: DP same as 542. 01 matrix.
- [0286.Walls_and_Gates](Solutions/0286.Walls_and_Gates.py) (M) <br>
 求最小距离问题，必须用bfs. Step 1: append all the gates into the queue; Step 2: change all the EMPTY rooms to a value that equals the layer  number, 必须层序遍历才可以保证每次都能变成最小距离.<br>
- [1197.Minimum_Knight_Moves.py](Solutions/1197.Minimum_Knight_Moves.py) (!!M) <br>
solution 1: 利用对称性质: x,y=abs(x),abs(y); q.append(neighbor) only if (-2 <= next_x <= x + 2 and -2 <= next_y <= y + 2); 1816 ms
solution 2!!!: 从source和destination两端同时进行bfs!!!!注意双端bfs传进去的参数包含q and visited, bfs返回值是updated q and visited. cnt+=1的操作在主函数中进行. while true的结束条件: if visited_src & visited_des: return cnt_src + cnt_des; 452 ms
solution 3: recurrsion with memorization: cache[(x, y)] = min(dp(abs(x-1), abs(y-2)), dp(abs(x-2), abs(y-1))) + 1; 60 ms

864(H)
BFS algorithm can be used to solve a lot of problems of finding shortest distance. In this problem, we may visit a point more than one times, simply storing visited position is not enough. We need to save (pos, keys_collected) in the visited set, because visiting the same pos without getting new key is not allowed, but in order to get a new key, we may visit a certain pos, after getting the key, we may go back and visit the pos again.

### [4.序列化知识点]() 
序列化：将“内存”中结构化的数据变成“字符串”的过程 序列化:object to string 反序列化:string to object<br>
什么时候需要序列化?<br>
1. 将内存中的数据持久化存储时<br>
内存中重要的数据不能只是呆在内存里，这样断电就没有了，所需需要用一种方式写入硬盘，在需要的 时候，能否再从硬盘中读出来在内存中重新创建<br>
2. 网络传输时 机器与机器之间交换数据的时候，不可能互相去读对方的内存。只能讲数据变成字符流数据(字符串)后<br>
通过网络传输过去。接受的一方再将字符串解析后到内存中。 常用的一些序列化手段:<br>
• XML<br>
• Json<br>
• Thrift (by Facebook)<br>
• ProtoBuf (by Google)<br>

序列化算法：一些序列化的例子:<br>
• 比如一个数组，里面都是整数，我们可以简单的序列化为”[1,2,3]”<br>
• 一个整数链表，我们可以序列化为，”1->2->3”<br>
• 一个哈希表(HashMap)，我们可以序列化为，”{\”key\”: \”value\”}”<br>
序列化算法设计时需要考虑的因素:<br>
• 压缩率。对于网络传输和磁盘存储而言，当然希望更节省。<br>
• 如 Thrift, ProtoBuf 都是为了更快的传输数据和节省存储空间而设计的。<br>
• 可读性。我们希望开发人员，能够通过序列化后的数据直接看懂原始数据是什么。<br>
• 如 Json，LintCode 的输入数据 <br>

- [0449.Serialize and Deserialize BST](Solutions/0449.Serialize_and_Deserialize_BST.java) (M) <br>
Same as 297. Solution says since BST, the answer could be as compact as possible. Don't know how? 
TODO:多记
  
### [5.拓扑排序 Topological Sorting](/Data-Structure.py) 
有向图的问题，可以检测有向图是否有环！必考，其实也非常模板化，一定要记住。
  
Remember：
Three steps: 
1. 从数字关系求出每个节点的inDegrees（就是找节点与相邻节点的依赖关系） (inDegrees = collections.defaultdict(int))，key是node, val是这个node的indegree值; 
2. 和每个节点的neighbors （neighbors = collections.defaultdict(list)), key是node, val是装有这个node的neighbor的list; 
3. 然后 BFS，背诵模板就可以了。
 
Three steps: 
  1. construct a dictoinary of adjacency list for the graph   hashmap存储临接关系
  2. get in_degree information for all nodes
  3. topological sort - bfs
  step I: initialze q by putting all in_degree = 0 into q
  step II: keep adding in_degree = 0 node into q and pop out while updating res

- [0127.Topological Sorting.java ](Solutions/0127.Topological_Sorting.py) (!!LintCode)  <br>
有向图的问题，可以检测有向图是否有环！必考，其实也非常模板化，一定要记住。Three steps: 1. 从数字关系求出每个节点的inDegrees（就是找节点与相邻节点的依赖关系） (inDegrees = collections.defaultdict(int))，key是node, val是这个node的indegree值; 2. 和每个节点的neighbors （neighbors = collections.defaultdict(list)), key是node, val是装有这个node的neighbor的list; 3. 然后 BFS，背诵模板就可以了。
利用双端BFS大大提高速度，注意双端bfs传进去的参数包含q and visited, bfs返回值是updated q and visited. 双端bfs是src/des每走一步判断一下if visited_src & visited_des: return step; 在双端BFS的过程中判断if not q_src or not q_des: 则说明q_src或q_des里面的所有possible neighbor都不在wordList里面，也就是没有必要继续进行了; The idea behind bidirectional search is to run two simultaneous searches: one forward from the initial state and the other backward from the destination state — hoping that the two searches meet in the middle. The motivation is that b^(d/2) + b^(d/2) is much less than b^d. b is branch number, d is depth. 这题最好定义一个wordSet = set(wordList)来降低时间寻找下一个neighborWord的复杂度到O(26L);
- [0207.Course_Schedule.](Solutions/0207.Course_Schedule.py) (!!M)  <br>
  套用模板分三步：1. construct a dictoinary of adjacency list for the graph; 2. get in_degree information for all nodes; 3. topological sort -  bfs: step I: initialze q by putting all in_degree = 0 into q; step II: keep adding in_degree = 0 node into q and pop out while updating res  
- [0210.Course_Schedule_II](Solutions/0210.Course_Schedule_II.py) (!!M)  <br> 
套用模板 return res if len(res) == numCourses else []. Google follow up: 打印出所有可能的选课组合，感觉有点像word ladder I and II.
- [1136.Parallel_Courses](Solutions/1136.Parallel_Courses.py) (M)  <br> 
Solution:注意课程是从1到N
- [0605.Sequence_Reconstruction](Solutions/0605.Sequence_Reconstruction.py) (M) (!!LintCode) <br> 
裸拓扑排序:判断是否只存在一个拓扑排序的序列 只需要保证队列中一直最多只有1个元素即可 
TODO:not work
  
### [6.Best First Search - Dijkstra’s 类型1 (max/min sum of the path problem) ](/Data-Structure.py) 

Dijkstra's - 用于问题：起点和终点定了，寻找有权图的最短路径，又叫best first search, 类贪心算法，实现方式和bfs很像.
个人感觉Dijkstra就是贪心版的bfs, bfs是勤勤恳恳一层一层推进，一层没访问完绝不访问下一层。Dijkstra就很贪心了，才不一层一层地走呢，他每次都想走最low cost的。

如何实现每次走最low cost的呢？用一个heapq来store  a pair: (currCost to reach the node, node)
为什么Dijkstra算法比bfs快？首先很类似，为什么快呢？因为Dijkstra 的heapq pop出每一层的时候和bfs 普通q pop出每一层的元素顺序是不一样的。
Dijkstra's算法只适用于无环图
不能将Dijkstra's算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——Bellman-Ford algorithm
如果是非加权图中查找最短路径，用普通 bfs 就可以了

Dijkstra's算法写代码时需要注意的点：
需要一个heapq, heapq sotres (curr_cost, curr_node)
需要一个额外的空间distance/costs, 定义成dictionary, 快速记录和查找到从源节点某个节点的distance/cost, 同时可以当visited set用.

**Best First Search - Dijkstra’s 类型1 (max/min sum of the path problem)**
  
- [0743.Network_Delay_Time](Solutions/0743.Network_Delay_Time.py) (!!M)  <br>
带权值的有向图求单源节点出发的最短路径问题马上就想到Dijkstra, O(NlogN + E) N is # nodes, E is # edges
Dijkstra就是贪心版的bfs, bfs是勤勤恳恳一层一层推进，一层没访问完绝不访问下一层。Dijkstra就很贪心了，才不一层一层地走呢，他每次都想走最low cost的。如何实现每次走最low cost的呢？用一个heapq来store a pair: (currCost to reach the node, node), 这样每次pop出来的就都最low cost的node了，再去访问这个node的neighbors，把这些neighbors都加到hq中，代码比较短。思路其实与23. Merge k Sorted Lists非常类似，把23里的linked list加上一个虚拟头节点连接所有的头节点，然后把Linked list node的val改成边的权值，那就变成了单源节点出发求访问到所有节点的最短路径。 
- [0787.Cheapest_Flights_Within_K_Stops](Solutions/0787.Cheapest_Flights_Within_K_Stops.py) (!!M)  <br>
有向图，带权值，找从单源出发最佳路径问题：Dijkstra's algorithm O(NlogN + E)
hq 需要 store (cost, stops, airports), 与743相比少了一个currNode in costs: continue因为次好路径也可能是最后的结果，这是由于最好路径可能不满足stops < K; 这题需要加一个 if currStops >= K: continue

**Best First Search - Dijkstra’s 类型2 (max/min of min/max problem)**  
  
- [1102.Path_With_Maximum_Minimum_Value](Solutions/1102.Path_With_Maximum_Minimum_Value.py) (!!M)  <br>
TODO:代码不懂  
让路径的最小值最大！！！策略：让每次走最大的node.最终就会路径的最小值的最大。max_minvals用来记录已经访问过的值。  
Solution 1: Dijkstra's : 每次都把目前为止最小值最大的那个path的那个cueeNode pop出来，从那个currNode开始往后走. maintain a heapq to store (the minimum value in the path so far till the currPos, currPos); each time, we push (min(nextVal, currMinVal), nextPos); O(MNlogMN), O(MN)。
- [0778.Swim_in_Rising_Water](Solutions/0778.Swim_in_Rising_Water.py) (!!H)  <br>
find a path with the minimum max-height in the path. 采用Dikstra, 每次pop出来的都是min height就可了 - O(N^2* log(N^2)), where N is the lens of grid. Google 面经：有一个nxn矩阵，信使从(0, 0)出发，想走到(n-1, n-1)去报信， 中途会有一些狮子/敌营，我们离狮子的距离越远越安全，问为了尽可能到达目的地，离狮子最大的最近距离是多少？
